var ds=Object.defineProperty,us=Object.defineProperties;var ms=Object.getOwnPropertyDescriptors;var ar=Object.getOwnPropertySymbols;var Go=Object.prototype.hasOwnProperty,Ho=Object.prototype.propertyIsEnumerable;var zo=(i,e,t)=>e in i?ds(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,Q=(i,e)=>{for(var t in e||(e={}))Go.call(e,t)&&zo(i,t,e[t]);if(ar)for(var t of ar(e))Ho.call(e,t)&&zo(i,t,e[t]);return i},de=(i,e)=>us(i,ms(e));var Wo=(i,e)=>{var t={};for(var n in i)Go.call(i,n)&&e.indexOf(n)<0&&(t[n]=i[n]);if(i!=null&&ar)for(var n of ar(i))e.indexOf(n)<0&&Ho.call(i,n)&&(t[n]=i[n]);return t};class h extends Array{constructor(e,t){if(super(e),this.sign=t,Object.setPrototypeOf(this,h.prototype),e>h.__kMaxLength)throw new RangeError("Maximum BigInt size exceeded")}static BigInt(e){var t=Math.floor,n=Number.isFinite;if(typeof e=="number"){if(e===0)return h.__zero();if(h.__isOneDigitInt(e))return 0>e?h.__oneDigit(-e,!0):h.__oneDigit(e,!1);if(!n(e)||t(e)!==e)throw new RangeError("The number "+e+" cannot be converted to BigInt because it is not an integer");return h.__fromDouble(e)}if(typeof e=="string"){const r=h.__fromString(e);if(r===null)throw new SyntaxError("Cannot convert "+e+" to a BigInt");return r}if(typeof e=="boolean")return e===!0?h.__oneDigit(1,!1):h.__zero();if(typeof e=="object"){if(e.constructor===h)return e;const r=h.__toPrimitive(e);return h.BigInt(r)}throw new TypeError("Cannot convert "+e+" to a BigInt")}toDebugString(){const e=["BigInt["];for(const t of this)e.push((t&&(t>>>0).toString(16))+", ");return e.push("]"),e.join("")}toString(e=10){if(2>e||36<e)throw new RangeError("toString() radix argument must be between 2 and 36");return this.length===0?"0":(e&e-1)==0?h.__toStringBasePowerOfTwo(this,e):h.__toStringGeneric(this,e,!1)}valueOf(){throw new Error("Convert JSBI instances to native numbers using `toNumber`.")}static toNumber(e){const t=e.length;if(t===0)return 0;if(t===1){const p=e.__unsignedDigit(0);return e.sign?-p:p}const n=e.__digit(t-1),r=h.__clz30(n),s=30*t-r;if(1024<s)return e.sign?-1/0:1/0;let a=s-1,c=n,l=t-1;const d=r+3;let m=d===32?0:c<<d;m>>>=12;const u=d-12;let f=12<=d?0:c<<20+d,y=20+d;for(0<u&&0<l&&(l--,c=e.__digit(l),m|=c>>>30-u,f=c<<u+2,y=u+2);0<y&&0<l;)l--,c=e.__digit(l),f|=30<=y?c<<y-30:c>>>30-y,y-=30;const g=h.__decideRounding(e,y,l,c);if((g===1||g===0&&(1&f)==1)&&(f=f+1>>>0,f===0&&(m++,m>>>20!=0&&(m=0,a++,1023<a))))return e.sign?-1/0:1/0;const w=e.sign?-2147483648:0;return a=a+1023<<20,h.__kBitConversionInts[1]=w|a|m,h.__kBitConversionInts[0]=f,h.__kBitConversionDouble[0]}static unaryMinus(e){if(e.length===0)return e;const t=e.__copy();return t.sign=!e.sign,t}static bitwiseNot(e){return e.sign?h.__absoluteSubOne(e).__trim():h.__absoluteAddOne(e,!0)}static exponentiate(e,t){if(t.sign)throw new RangeError("Exponent must be positive");if(t.length===0)return h.__oneDigit(1,!1);if(e.length===0)return e;if(e.length===1&&e.__digit(0)===1)return e.sign&&(1&t.__digit(0))==0?h.unaryMinus(e):e;if(1<t.length)throw new RangeError("BigInt too big");let n=t.__unsignedDigit(0);if(n===1)return e;if(n>=h.__kMaxLengthBits)throw new RangeError("BigInt too big");if(e.length===1&&e.__digit(0)===2){const a=1+(0|n/30),c=e.sign&&(1&n)!=0,l=new h(a,c);l.__initializeDigits();const d=1<<n%30;return l.__setDigit(a-1,d),l}let r=null,s=e;for((1&n)!=0&&(r=e),n>>=1;n!==0;n>>=1)s=h.multiply(s,s),(1&n)!=0&&(r===null?r=s:r=h.multiply(r,s));return r}static multiply(e,t){if(e.length===0)return e;if(t.length===0)return t;let n=e.length+t.length;30<=e.__clzmsd()+t.__clzmsd()&&n--;const r=new h(n,e.sign!==t.sign);r.__initializeDigits();for(let s=0;s<e.length;s++)h.__multiplyAccumulate(t,e.__digit(s),r,s);return r.__trim()}static divide(e,t){if(t.length===0)throw new RangeError("Division by zero");if(0>h.__absoluteCompare(e,t))return h.__zero();const n=e.sign!==t.sign,r=t.__unsignedDigit(0);let s;if(t.length===1&&32767>=r){if(r===1)return n===e.sign?e:h.unaryMinus(e);s=h.__absoluteDivSmall(e,r,null)}else s=h.__absoluteDivLarge(e,t,!0,!1);return s.sign=n,s.__trim()}static remainder(e,t){if(t.length===0)throw new RangeError("Division by zero");if(0>h.__absoluteCompare(e,t))return e;const n=t.__unsignedDigit(0);if(t.length===1&&32767>=n){if(n===1)return h.__zero();const s=h.__absoluteModSmall(e,n);return s===0?h.__zero():h.__oneDigit(s,e.sign)}const r=h.__absoluteDivLarge(e,t,!1,!0);return r.sign=e.sign,r.__trim()}static add(e,t){const n=e.sign;return n===t.sign?h.__absoluteAdd(e,t,n):0<=h.__absoluteCompare(e,t)?h.__absoluteSub(e,t,n):h.__absoluteSub(t,e,!n)}static subtract(e,t){const n=e.sign;return n===t.sign?0<=h.__absoluteCompare(e,t)?h.__absoluteSub(e,t,n):h.__absoluteSub(t,e,!n):h.__absoluteAdd(e,t,n)}static leftShift(e,t){return t.length===0||e.length===0?e:t.sign?h.__rightShiftByAbsolute(e,t):h.__leftShiftByAbsolute(e,t)}static signedRightShift(e,t){return t.length===0||e.length===0?e:t.sign?h.__leftShiftByAbsolute(e,t):h.__rightShiftByAbsolute(e,t)}static unsignedRightShift(){throw new TypeError("BigInts have no unsigned right shift; use >> instead")}static lessThan(e,t){return 0>h.__compareToBigInt(e,t)}static lessThanOrEqual(e,t){return 0>=h.__compareToBigInt(e,t)}static greaterThan(e,t){return 0<h.__compareToBigInt(e,t)}static greaterThanOrEqual(e,t){return 0<=h.__compareToBigInt(e,t)}static equal(e,t){if(e.sign!==t.sign||e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e.__digit(n)!==t.__digit(n))return!1;return!0}static notEqual(e,t){return!h.equal(e,t)}static bitwiseAnd(e,t){var n=Math.max;if(!e.sign&&!t.sign)return h.__absoluteAnd(e,t).__trim();if(e.sign&&t.sign){const r=n(e.length,t.length)+1;let s=h.__absoluteSubOne(e,r);const a=h.__absoluteSubOne(t);return s=h.__absoluteOr(s,a,s),h.__absoluteAddOne(s,!0,s).__trim()}return e.sign&&([e,t]=[t,e]),h.__absoluteAndNot(e,h.__absoluteSubOne(t)).__trim()}static bitwiseXor(e,t){var n=Math.max;if(!e.sign&&!t.sign)return h.__absoluteXor(e,t).__trim();if(e.sign&&t.sign){const a=n(e.length,t.length),c=h.__absoluteSubOne(e,a),l=h.__absoluteSubOne(t);return h.__absoluteXor(c,l,c).__trim()}const r=n(e.length,t.length)+1;e.sign&&([e,t]=[t,e]);let s=h.__absoluteSubOne(t,r);return s=h.__absoluteXor(s,e,s),h.__absoluteAddOne(s,!0,s).__trim()}static bitwiseOr(e,t){var n=Math.max;const r=n(e.length,t.length);if(!e.sign&&!t.sign)return h.__absoluteOr(e,t).__trim();if(e.sign&&t.sign){let a=h.__absoluteSubOne(e,r);const c=h.__absoluteSubOne(t);return a=h.__absoluteAnd(a,c,a),h.__absoluteAddOne(a,!0,a).__trim()}e.sign&&([e,t]=[t,e]);let s=h.__absoluteSubOne(t,r);return s=h.__absoluteAndNot(s,e,s),h.__absoluteAddOne(s,!0,s).__trim()}static asIntN(e,t){var n=Math.floor;if(t.length===0)return t;if(e=n(e),0>e)throw new RangeError("Invalid value: not (convertible to) a safe integer");if(e===0)return h.__zero();if(e>=h.__kMaxLengthBits)return t;const r=0|(e+29)/30;if(t.length<r)return t;const s=t.__unsignedDigit(r-1),a=1<<(e-1)%30;if(t.length===r&&s<a)return t;if((s&a)!==a)return h.__truncateToNBits(e,t);if(!t.sign)return h.__truncateAndSubFromPowerOfTwo(e,t,!0);if((s&a-1)==0){for(let c=r-2;0<=c;c--)if(t.__digit(c)!==0)return h.__truncateAndSubFromPowerOfTwo(e,t,!1);return t.length===r&&s===a?t:h.__truncateToNBits(e,t)}return h.__truncateAndSubFromPowerOfTwo(e,t,!1)}static asUintN(e,t){var n=Math.floor;if(t.length===0)return t;if(e=n(e),0>e)throw new RangeError("Invalid value: not (convertible to) a safe integer");if(e===0)return h.__zero();if(t.sign){if(e>h.__kMaxLengthBits)throw new RangeError("BigInt too big");return h.__truncateAndSubFromPowerOfTwo(e,t,!1)}if(e>=h.__kMaxLengthBits)return t;const r=0|(e+29)/30;if(t.length<r)return t;const s=e%30;return t.length==r&&(s===0||t.__digit(r-1)>>>s==0)?t:h.__truncateToNBits(e,t)}static ADD(e,t){if(e=h.__toPrimitive(e),t=h.__toPrimitive(t),typeof e=="string")return typeof t!="string"&&(t=t.toString()),e+t;if(typeof t=="string")return e.toString()+t;if(e=h.__toNumeric(e),t=h.__toNumeric(t),h.__isBigInt(e)&&h.__isBigInt(t))return h.add(e,t);if(typeof e=="number"&&typeof t=="number")return e+t;throw new TypeError("Cannot mix BigInt and other types, use explicit conversions")}static LT(e,t){return h.__compare(e,t,0)}static LE(e,t){return h.__compare(e,t,1)}static GT(e,t){return h.__compare(e,t,2)}static GE(e,t){return h.__compare(e,t,3)}static EQ(e,t){for(;;){if(h.__isBigInt(e))return h.__isBigInt(t)?h.equal(e,t):h.EQ(t,e);if(typeof e=="number"){if(h.__isBigInt(t))return h.__equalToNumber(t,e);if(typeof t!="object")return e==t;t=h.__toPrimitive(t)}else if(typeof e=="string"){if(h.__isBigInt(t))return e=h.__fromString(e),e!==null&&h.equal(e,t);if(typeof t!="object")return e==t;t=h.__toPrimitive(t)}else if(typeof e=="boolean"){if(h.__isBigInt(t))return h.__equalToNumber(t,+e);if(typeof t!="object")return e==t;t=h.__toPrimitive(t)}else if(typeof e=="symbol"){if(h.__isBigInt(t))return!1;if(typeof t!="object")return e==t;t=h.__toPrimitive(t)}else if(typeof e=="object"){if(typeof t=="object"&&t.constructor!==h)return e==t;e=h.__toPrimitive(e)}else return e==t}}static NE(e,t){return!h.EQ(e,t)}static DataViewGetBigInt64(e,t,n=!1){return h.asIntN(64,h.DataViewGetBigUint64(e,t,n))}static DataViewGetBigUint64(e,t,n=!1){const[r,s]=n?[4,0]:[0,4],a=e.getUint32(t+r,n),c=e.getUint32(t+s,n),l=new h(3,!1);return l.__setDigit(0,1073741823&c),l.__setDigit(1,(268435455&a)<<2|c>>>30),l.__setDigit(2,a>>>28),l.__trim()}static DataViewSetBigInt64(e,t,n,r=!1){h.DataViewSetBigUint64(e,t,n,r)}static DataViewSetBigUint64(e,t,n,r=!1){n=h.asUintN(64,n);let s=0,a=0;if(0<n.length&&(a=n.__digit(0),1<n.length)){const d=n.__digit(1);a|=d<<30,s=d>>>2,2<n.length&&(s|=n.__digit(2)<<28)}const[c,l]=r?[4,0]:[0,4];e.setUint32(t+c,s,r),e.setUint32(t+l,a,r)}static __zero(){return new h(0,!1)}static __oneDigit(e,t){const n=new h(1,t);return n.__setDigit(0,e),n}__copy(){const e=new h(this.length,this.sign);for(let t=0;t<this.length;t++)e[t]=this[t];return e}__trim(){let e=this.length,t=this[e-1];for(;t===0;)e--,t=this[e-1],this.pop();return e===0&&(this.sign=!1),this}__initializeDigits(){for(let e=0;e<this.length;e++)this[e]=0}static __decideRounding(e,t,n,r){if(0<t)return-1;let s;if(0>t)s=-t-1;else{if(n===0)return-1;n--,r=e.__digit(n),s=29}let a=1<<s;if((r&a)==0)return-1;if(a-=1,(r&a)!=0)return 1;for(;0<n;)if(n--,e.__digit(n)!==0)return 1;return 0}static __fromDouble(e){h.__kBitConversionDouble[0]=e;const t=2047&h.__kBitConversionInts[1]>>>20,n=t-1023,r=(0|n/30)+1,s=new h(r,0>e);let a=1048575&h.__kBitConversionInts[1]|1048576,c=h.__kBitConversionInts[0];const l=20,d=n%30;let m,u=0;if(d<20){const f=l-d;u=f+32,m=a>>>f,a=a<<32-f|c>>>f,c<<=32-f}else if(d===20)u=32,m=a,a=c,c=0;else{const f=d-l;u=32-f,m=a<<f|c>>>32-f,a=c<<f,c=0}s.__setDigit(r-1,m);for(let f=r-2;0<=f;f--)0<u?(u-=30,m=a>>>2,a=a<<30|c>>>2,c<<=30):m=0,s.__setDigit(f,m);return s.__trim()}static __isWhitespace(e){return 13>=e&&9<=e||(159>=e?e==32:131071>=e?e==160||e==5760:196607>=e?(e&=131071,10>=e||e==40||e==41||e==47||e==95||e==4096):e==65279)}static __fromString(e,t=0){let n=0;const r=e.length;let s=0;if(s===r)return h.__zero();let a=e.charCodeAt(s);for(;h.__isWhitespace(a);){if(++s===r)return h.__zero();a=e.charCodeAt(s)}if(a===43){if(++s===r)return null;a=e.charCodeAt(s),n=1}else if(a===45){if(++s===r)return null;a=e.charCodeAt(s),n=-1}if(t===0){if(t=10,a===48){if(++s===r)return h.__zero();if(a=e.charCodeAt(s),a===88||a===120){if(t=16,++s===r)return null;a=e.charCodeAt(s)}else if(a===79||a===111){if(t=8,++s===r)return null;a=e.charCodeAt(s)}else if(a===66||a===98){if(t=2,++s===r)return null;a=e.charCodeAt(s)}}}else if(t===16&&a===48){if(++s===r)return h.__zero();if(a=e.charCodeAt(s),a===88||a===120){if(++s===r)return null;a=e.charCodeAt(s)}}if(n!=0&&t!==10)return null;for(;a===48;){if(++s===r)return h.__zero();a=e.charCodeAt(s)}const c=r-s;let l=h.__kMaxBitsPerChar[t],d=h.__kBitsPerCharTableMultiplier-1;if(c>1073741824/l)return null;const m=l*c+d>>>h.__kBitsPerCharTableShift,u=new h(0|(m+29)/30,!1),f=10>t?t:10,y=10<t?t-10:0;if((t&t-1)==0){l>>=h.__kBitsPerCharTableShift;const g=[],w=[];let p=!1;do{let v=0,T=0;for(;;){let b;if(a-48>>>0<f)b=a-48;else if((32|a)-97>>>0<y)b=(32|a)-87;else{p=!0;break}if(T+=l,v=v<<l|b,++s===r){p=!0;break}if(a=e.charCodeAt(s),30<T+l)break}g.push(v),w.push(T)}while(!p);h.__fillFromParts(u,g,w)}else{u.__initializeDigits();let g=!1,w=0;do{let p=0,v=1;for(;;){let b;if(a-48>>>0<f)b=a-48;else if((32|a)-97>>>0<y)b=(32|a)-87;else{g=!0;break}const D=v*t;if(1073741823<D)break;if(v=D,p=p*t+b,w++,++s===r){g=!0;break}a=e.charCodeAt(s)}d=30*h.__kBitsPerCharTableMultiplier-1;const T=0|(l*w+d>>>h.__kBitsPerCharTableShift)/30;u.__inplaceMultiplyAdd(v,p,T)}while(!g)}if(s!==r){if(!h.__isWhitespace(a))return null;for(s++;s<r;s++)if(a=e.charCodeAt(s),!h.__isWhitespace(a))return null}return u.sign=n==-1,u.__trim()}static __fillFromParts(e,t,n){let r=0,s=0,a=0;for(let c=t.length-1;0<=c;c--){const l=t[c],d=n[c];s|=l<<a,a+=d,a===30?(e.__setDigit(r++,s),a=0,s=0):30<a&&(e.__setDigit(r++,1073741823&s),a-=30,s=l>>>d-a)}if(s!==0){if(r>=e.length)throw new Error("implementation bug");e.__setDigit(r++,s)}for(;r<e.length;r++)e.__setDigit(r,0)}static __toStringBasePowerOfTwo(e,t){const n=e.length;let r=t-1;r=(85&r>>>1)+(85&r),r=(51&r>>>2)+(51&r),r=(15&r>>>4)+(15&r);const s=r,a=t-1,c=e.__digit(n-1),l=h.__clz30(c);let d=0|(30*n-l+s-1)/s;if(e.sign&&d++,268435456<d)throw new Error("string too long");const m=Array(d);let u=d-1,f=0,y=0;for(let w=0;w<n-1;w++){const p=e.__digit(w),v=(f|p<<y)&a;m[u--]=h.__kConversionChars[v];const T=s-y;for(f=p>>>T,y=30-T;y>=s;)m[u--]=h.__kConversionChars[f&a],f>>>=s,y-=s}const g=(f|c<<y)&a;for(m[u--]=h.__kConversionChars[g],f=c>>>s-y;f!==0;)m[u--]=h.__kConversionChars[f&a],f>>>=s;if(e.sign&&(m[u--]="-"),u!=-1)throw new Error("implementation bug");return m.join("")}static __toStringGeneric(e,t,n){const r=e.length;if(r===0)return"";if(r===1){let w=e.__unsignedDigit(0).toString(t);return n===!1&&e.sign&&(w="-"+w),w}const s=30*r-h.__clz30(e.__digit(r-1)),a=h.__kMaxBitsPerChar[t],c=a-1;let l=s*h.__kBitsPerCharTableMultiplier;l+=c-1,l=0|l/c;const d=l+1>>1,m=h.exponentiate(h.__oneDigit(t,!1),h.__oneDigit(d,!1));let u,f;const y=m.__unsignedDigit(0);if(m.length===1&&32767>=y){u=new h(e.length,!1),u.__initializeDigits();let w=0;for(let p=2*e.length-1;0<=p;p--){const v=w<<15|e.__halfDigit(p);u.__setHalfDigit(p,0|v/y),w=0|v%y}f=w.toString(t)}else{const w=h.__absoluteDivLarge(e,m,!0,!0);u=w.quotient;const p=w.remainder.__trim();f=h.__toStringGeneric(p,t,!0)}u.__trim();let g=h.__toStringGeneric(u,t,!0);for(;f.length<d;)f="0"+f;return n===!1&&e.sign&&(g="-"+g),g+f}static __unequalSign(e){return e?-1:1}static __absoluteGreater(e){return e?-1:1}static __absoluteLess(e){return e?1:-1}static __compareToBigInt(e,t){const n=e.sign;if(n!==t.sign)return h.__unequalSign(n);const r=h.__absoluteCompare(e,t);return 0<r?h.__absoluteGreater(n):0>r?h.__absoluteLess(n):0}static __compareToNumber(e,t){if(h.__isOneDigitInt(t)){const n=e.sign,r=0>t;if(n!==r)return h.__unequalSign(n);if(e.length===0){if(r)throw new Error("implementation bug");return t===0?0:-1}if(1<e.length)return h.__absoluteGreater(n);const s=Math.abs(t),a=e.__unsignedDigit(0);return a>s?h.__absoluteGreater(n):a<s?h.__absoluteLess(n):0}return h.__compareToDouble(e,t)}static __compareToDouble(e,t){if(t!==t)return t;if(t===1/0)return-1;if(t===-1/0)return 1;const n=e.sign;if(n!==0>t)return h.__unequalSign(n);if(t===0)throw new Error("implementation bug: should be handled elsewhere");if(e.length===0)return-1;h.__kBitConversionDouble[0]=t;const r=2047&h.__kBitConversionInts[1]>>>20;if(r==2047)throw new Error("implementation bug: handled elsewhere");const s=r-1023;if(0>s)return h.__absoluteGreater(n);const a=e.length;let c=e.__digit(a-1);const l=h.__clz30(c),d=30*a-l,m=s+1;if(d<m)return h.__absoluteLess(n);if(d>m)return h.__absoluteGreater(n);let u=1048576|1048575&h.__kBitConversionInts[1],f=h.__kBitConversionInts[0];const y=20,g=29-l;if(g!==(0|(d-1)%30))throw new Error("implementation bug");let w,p=0;if(20>g){const v=y-g;p=v+32,w=u>>>v,u=u<<32-v|f>>>v,f<<=32-v}else if(g===20)p=32,w=u,u=f,f=0;else{const v=g-y;p=32-v,w=u<<v|f>>>32-v,u=f<<v,f=0}if(c>>>=0,w>>>=0,c>w)return h.__absoluteGreater(n);if(c<w)return h.__absoluteLess(n);for(let v=a-2;0<=v;v--){0<p?(p-=30,w=u>>>2,u=u<<30|f>>>2,f<<=30):w=0;const T=e.__unsignedDigit(v);if(T>w)return h.__absoluteGreater(n);if(T<w)return h.__absoluteLess(n)}if(u!==0||f!==0){if(p===0)throw new Error("implementation bug");return h.__absoluteLess(n)}return 0}static __equalToNumber(e,t){var n=Math.abs;return h.__isOneDigitInt(t)?t===0?e.length===0:e.length===1&&e.sign===0>t&&e.__unsignedDigit(0)===n(t):h.__compareToDouble(e,t)===0}static __comparisonResultToBool(e,t){return t===0?0>e:t===1?0>=e:t===2?0<e:t===3?0<=e:void 0}static __compare(e,t,n){if(e=h.__toPrimitive(e),t=h.__toPrimitive(t),typeof e=="string"&&typeof t=="string")switch(n){case 0:return e<t;case 1:return e<=t;case 2:return e>t;case 3:return e>=t}if(h.__isBigInt(e)&&typeof t=="string")return t=h.__fromString(t),t!==null&&h.__comparisonResultToBool(h.__compareToBigInt(e,t),n);if(typeof e=="string"&&h.__isBigInt(t))return e=h.__fromString(e),e!==null&&h.__comparisonResultToBool(h.__compareToBigInt(e,t),n);if(e=h.__toNumeric(e),t=h.__toNumeric(t),h.__isBigInt(e)){if(h.__isBigInt(t))return h.__comparisonResultToBool(h.__compareToBigInt(e,t),n);if(typeof t!="number")throw new Error("implementation bug");return h.__comparisonResultToBool(h.__compareToNumber(e,t),n)}if(typeof e!="number")throw new Error("implementation bug");if(h.__isBigInt(t))return h.__comparisonResultToBool(h.__compareToNumber(t,e),2^n);if(typeof t!="number")throw new Error("implementation bug");return n===0?e<t:n===1?e<=t:n===2?e>t:n===3?e>=t:void 0}__clzmsd(){return h.__clz30(this.__digit(this.length-1))}static __absoluteAdd(e,t,n){if(e.length<t.length)return h.__absoluteAdd(t,e,n);if(e.length===0)return e;if(t.length===0)return e.sign===n?e:h.unaryMinus(e);let r=e.length;(e.__clzmsd()===0||t.length===e.length&&t.__clzmsd()===0)&&r++;const s=new h(r,n);let a=0,c=0;for(;c<t.length;c++){const l=e.__digit(c)+t.__digit(c)+a;a=l>>>30,s.__setDigit(c,1073741823&l)}for(;c<e.length;c++){const l=e.__digit(c)+a;a=l>>>30,s.__setDigit(c,1073741823&l)}return c<s.length&&s.__setDigit(c,a),s.__trim()}static __absoluteSub(e,t,n){if(e.length===0)return e;if(t.length===0)return e.sign===n?e:h.unaryMinus(e);const r=new h(e.length,n);let s=0,a=0;for(;a<t.length;a++){const c=e.__digit(a)-t.__digit(a)-s;s=1&c>>>30,r.__setDigit(a,1073741823&c)}for(;a<e.length;a++){const c=e.__digit(a)-s;s=1&c>>>30,r.__setDigit(a,1073741823&c)}return r.__trim()}static __absoluteAddOne(e,t,n=null){const r=e.length;n===null?n=new h(r,t):n.sign=t;let s=1;for(let a=0;a<r;a++){const c=e.__digit(a)+s;s=c>>>30,n.__setDigit(a,1073741823&c)}return s!=0&&n.__setDigitGrow(r,1),n}static __absoluteSubOne(e,t){const n=e.length;t=t||n;const r=new h(t,!1);let s=1;for(let a=0;a<n;a++){const c=e.__digit(a)-s;s=1&c>>>30,r.__setDigit(a,1073741823&c)}if(s!=0)throw new Error("implementation bug");for(let a=n;a<t;a++)r.__setDigit(a,0);return r}static __absoluteAnd(e,t,n=null){let r=e.length,s=t.length,a=s;if(r<s){a=r;const d=e,m=r;e=t,r=s,t=d,s=m}let c=a;n===null?n=new h(c,!1):c=n.length;let l=0;for(;l<a;l++)n.__setDigit(l,e.__digit(l)&t.__digit(l));for(;l<c;l++)n.__setDigit(l,0);return n}static __absoluteAndNot(e,t,n=null){const r=e.length,s=t.length;let a=s;r<s&&(a=r);let c=r;n===null?n=new h(c,!1):c=n.length;let l=0;for(;l<a;l++)n.__setDigit(l,e.__digit(l)&~t.__digit(l));for(;l<r;l++)n.__setDigit(l,e.__digit(l));for(;l<c;l++)n.__setDigit(l,0);return n}static __absoluteOr(e,t,n=null){let r=e.length,s=t.length,a=s;if(r<s){a=r;const d=e,m=r;e=t,r=s,t=d,s=m}let c=r;n===null?n=new h(c,!1):c=n.length;let l=0;for(;l<a;l++)n.__setDigit(l,e.__digit(l)|t.__digit(l));for(;l<r;l++)n.__setDigit(l,e.__digit(l));for(;l<c;l++)n.__setDigit(l,0);return n}static __absoluteXor(e,t,n=null){let r=e.length,s=t.length,a=s;if(r<s){a=r;const d=e,m=r;e=t,r=s,t=d,s=m}let c=r;n===null?n=new h(c,!1):c=n.length;let l=0;for(;l<a;l++)n.__setDigit(l,e.__digit(l)^t.__digit(l));for(;l<r;l++)n.__setDigit(l,e.__digit(l));for(;l<c;l++)n.__setDigit(l,0);return n}static __absoluteCompare(e,t){const n=e.length-t.length;if(n!=0)return n;let r=e.length-1;for(;0<=r&&e.__digit(r)===t.__digit(r);)r--;return 0>r?0:e.__unsignedDigit(r)>t.__unsignedDigit(r)?1:-1}static __multiplyAccumulate(e,t,n,r){if(t===0)return;const s=32767&t,a=t>>>15;let c=0,l=0;for(let d,m=0;m<e.length;m++,r++){d=n.__digit(r);const u=e.__digit(m),f=32767&u,y=u>>>15,g=h.__imul(f,s),w=h.__imul(f,a),p=h.__imul(y,s),v=h.__imul(y,a);d+=l+g+c,c=d>>>30,d&=1073741823,d+=((32767&w)<<15)+((32767&p)<<15),c+=d>>>30,l=v+(w>>>15)+(p>>>15),n.__setDigit(r,1073741823&d)}for(;c!=0||l!==0;r++){let d=n.__digit(r);d+=c+l,l=0,c=d>>>30,n.__setDigit(r,1073741823&d)}}static __internalMultiplyAdd(e,t,n,r,s){let a=n,c=0;for(let l=0;l<r;l++){const d=e.__digit(l),m=h.__imul(32767&d,t),u=h.__imul(d>>>15,t),f=m+((32767&u)<<15)+c+a;a=f>>>30,c=u>>>15,s.__setDigit(l,1073741823&f)}if(s.length>r)for(s.__setDigit(r++,a+c);r<s.length;)s.__setDigit(r++,0);else if(a+c!==0)throw new Error("implementation bug")}__inplaceMultiplyAdd(e,t,n){n>this.length&&(n=this.length);const r=32767&e,s=e>>>15;let a=0,c=t;for(let l=0;l<n;l++){const d=this.__digit(l),m=32767&d,u=d>>>15,f=h.__imul(m,r),y=h.__imul(m,s),g=h.__imul(u,r),w=h.__imul(u,s);let p=c+f+a;a=p>>>30,p&=1073741823,p+=((32767&y)<<15)+((32767&g)<<15),a+=p>>>30,c=w+(y>>>15)+(g>>>15),this.__setDigit(l,1073741823&p)}if(a!=0||c!==0)throw new Error("implementation bug")}static __absoluteDivSmall(e,t,n=null){n===null&&(n=new h(e.length,!1));let r=0;for(let s,a=2*e.length-1;0<=a;a-=2){s=(r<<15|e.__halfDigit(a))>>>0;const c=0|s/t;r=0|s%t,s=(r<<15|e.__halfDigit(a-1))>>>0;const l=0|s/t;r=0|s%t,n.__setDigit(a>>>1,c<<15|l)}return n}static __absoluteModSmall(e,t){let n=0;for(let r=2*e.length-1;0<=r;r--){const s=(n<<15|e.__halfDigit(r))>>>0;n=0|s%t}return n}static __absoluteDivLarge(e,t,n,r){const s=t.__halfDigitLength(),a=t.length,c=e.__halfDigitLength()-s;let l=null;n&&(l=new h(c+2>>>1,!1),l.__initializeDigits());const d=new h(s+2>>>1,!1);d.__initializeDigits();const m=h.__clz15(t.__halfDigit(s-1));0<m&&(t=h.__specialLeftShift(t,m,0));const u=h.__specialLeftShift(e,m,1),f=t.__halfDigit(s-1);let y=0;for(let g,w=c;0<=w;w--){g=32767;const p=u.__halfDigit(w+s);if(p!==f){const T=(p<<15|u.__halfDigit(w+s-1))>>>0;g=0|T/f;let b=0|T%f;const D=t.__halfDigit(s-2),_=u.__halfDigit(w+s-2);for(;h.__imul(g,D)>>>0>(b<<16|_)>>>0&&(g--,b+=f,!(32767<b)););}h.__internalMultiplyAdd(t,g,0,a,d);let v=u.__inplaceSub(d,w,s+1);v!==0&&(v=u.__inplaceAdd(t,w,s),u.__setHalfDigit(w+s,32767&u.__halfDigit(w+s)+v),g--),n&&(1&w?y=g<<15:l.__setDigit(w>>>1,y|g))}if(r)return u.__inplaceRightShift(m),n?{quotient:l,remainder:u}:u;if(n)return l;throw new Error("unreachable")}static __clz15(e){return h.__clz30(e)-15}__inplaceAdd(e,t,n){let r=0;for(let s=0;s<n;s++){const a=this.__halfDigit(t+s)+e.__halfDigit(s)+r;r=a>>>15,this.__setHalfDigit(t+s,32767&a)}return r}__inplaceSub(e,t,n){let r=0;if(1&t){t>>=1;let s=this.__digit(t),a=32767&s,c=0;for(;c<n-1>>>1;c++){const m=e.__digit(c),u=(s>>>15)-(32767&m)-r;r=1&u>>>15,this.__setDigit(t+c,(32767&u)<<15|32767&a),s=this.__digit(t+c+1),a=(32767&s)-(m>>>15)-r,r=1&a>>>15}const l=e.__digit(c),d=(s>>>15)-(32767&l)-r;if(r=1&d>>>15,this.__setDigit(t+c,(32767&d)<<15|32767&a),t+c+1>=this.length)throw new RangeError("out of bounds");(1&n)==0&&(s=this.__digit(t+c+1),a=(32767&s)-(l>>>15)-r,r=1&a>>>15,this.__setDigit(t+e.length,1073709056&s|32767&a))}else{t>>=1;let s=0;for(;s<e.length-1;s++){const m=this.__digit(t+s),u=e.__digit(s),f=(32767&m)-(32767&u)-r;r=1&f>>>15;const y=(m>>>15)-(u>>>15)-r;r=1&y>>>15,this.__setDigit(t+s,(32767&y)<<15|32767&f)}const a=this.__digit(t+s),c=e.__digit(s),l=(32767&a)-(32767&c)-r;r=1&l>>>15;let d=0;(1&n)==0&&(d=(a>>>15)-(c>>>15)-r,r=1&d>>>15),this.__setDigit(t+s,(32767&d)<<15|32767&l)}return r}__inplaceRightShift(e){if(e===0)return;let t=this.__digit(0)>>>e;const n=this.length-1;for(let r=0;r<n;r++){const s=this.__digit(r+1);this.__setDigit(r,1073741823&s<<30-e|t),t=s>>>e}this.__setDigit(n,t)}static __specialLeftShift(e,t,n){const r=e.length,s=new h(r+n,!1);if(t===0){for(let c=0;c<r;c++)s.__setDigit(c,e.__digit(c));return 0<n&&s.__setDigit(r,0),s}let a=0;for(let c=0;c<r;c++){const l=e.__digit(c);s.__setDigit(c,1073741823&l<<t|a),a=l>>>30-t}return 0<n&&s.__setDigit(r,a),s}static __leftShiftByAbsolute(e,t){const n=h.__toShiftAmount(t);if(0>n)throw new RangeError("BigInt too big");const r=0|n/30,s=n%30,a=e.length,c=s!==0&&e.__digit(a-1)>>>30-s!=0,l=a+r+(c?1:0),d=new h(l,e.sign);if(s===0){let m=0;for(;m<r;m++)d.__setDigit(m,0);for(;m<l;m++)d.__setDigit(m,e.__digit(m-r))}else{let m=0;for(let u=0;u<r;u++)d.__setDigit(u,0);for(let u=0;u<a;u++){const f=e.__digit(u);d.__setDigit(u+r,1073741823&f<<s|m),m=f>>>30-s}if(c)d.__setDigit(a+r,m);else if(m!==0)throw new Error("implementation bug")}return d.__trim()}static __rightShiftByAbsolute(e,t){const n=e.length,r=e.sign,s=h.__toShiftAmount(t);if(0>s)return h.__rightShiftByMaximum(r);const a=0|s/30,c=s%30;let l=n-a;if(0>=l)return h.__rightShiftByMaximum(r);let d=!1;if(r){if((e.__digit(a)&(1<<c)-1)!=0)d=!0;else for(let u=0;u<a;u++)if(e.__digit(u)!==0){d=!0;break}}d&&c===0&&~e.__digit(n-1)==0&&l++;let m=new h(l,r);if(c===0){m.__setDigit(l-1,0);for(let u=a;u<n;u++)m.__setDigit(u-a,e.__digit(u))}else{let u=e.__digit(a)>>>c;const f=n-a-1;for(let y=0;y<f;y++){const g=e.__digit(y+a+1);m.__setDigit(y,1073741823&g<<30-c|u),u=g>>>c}m.__setDigit(f,u)}return d&&(m=h.__absoluteAddOne(m,!0,m)),m.__trim()}static __rightShiftByMaximum(e){return e?h.__oneDigit(1,!0):h.__zero()}static __toShiftAmount(e){if(1<e.length)return-1;const t=e.__unsignedDigit(0);return t>h.__kMaxLengthBits?-1:t}static __toPrimitive(e,t="default"){if(typeof e!="object"||e.constructor===h)return e;if(typeof Symbol!="undefined"&&typeof Symbol.toPrimitive=="symbol"){const s=e[Symbol.toPrimitive];if(s){const a=s(t);if(typeof a!="object")return a;throw new TypeError("Cannot convert object to primitive value")}}const n=e.valueOf;if(n){const s=n.call(e);if(typeof s!="object")return s}const r=e.toString;if(r){const s=r.call(e);if(typeof s!="object")return s}throw new TypeError("Cannot convert object to primitive value")}static __toNumeric(e){return h.__isBigInt(e)?e:+e}static __isBigInt(e){return typeof e=="object"&&e!==null&&e.constructor===h}static __truncateToNBits(e,t){const n=0|(e+29)/30,r=new h(n,t.sign),s=n-1;for(let c=0;c<s;c++)r.__setDigit(c,t.__digit(c));let a=t.__digit(s);if(e%30!=0){const c=32-e%30;a=a<<c>>>c}return r.__setDigit(s,a),r.__trim()}static __truncateAndSubFromPowerOfTwo(e,t,n){var r=Math.min;const s=0|(e+29)/30,a=new h(s,n);let c=0;const l=s-1;let d=0;for(const y=r(l,t.length);c<y;c++){const g=0-t.__digit(c)-d;d=1&g>>>30,a.__setDigit(c,1073741823&g)}for(;c<l;c++)a.__setDigit(c,0|1073741823&-d);let m=l<t.length?t.__digit(l):0;const u=e%30;let f;if(u==0)f=0-m-d,f&=1073741823;else{const y=32-u;m=m<<y>>>y;const g=1<<32-y;f=g-m-d,f&=g-1}return a.__setDigit(l,f),a.__trim()}__digit(e){return this[e]}__unsignedDigit(e){return this[e]>>>0}__setDigit(e,t){this[e]=0|t}__setDigitGrow(e,t){this[e]=0|t}__halfDigitLength(){const e=this.length;return 32767>=this.__unsignedDigit(e-1)?2*e-1:2*e}__halfDigit(e){return 32767&this[e>>>1]>>>15*(1&e)}__setHalfDigit(e,t){const n=e>>>1,r=this.__digit(n),s=1&e?32767&r|t<<15:1073709056&r|32767&t;this.__setDigit(n,s)}static __digitPow(e,t){let n=1;for(;0<t;)1&t&&(n*=e),t>>>=1,e*=e;return n}static __isOneDigitInt(e){return(1073741823&e)===e}}h.__kMaxLength=33554432,h.__kMaxLengthBits=h.__kMaxLength<<5,h.__kMaxBitsPerChar=[0,0,32,51,64,75,83,90,96,102,107,111,115,119,122,126,128,131,134,136,139,141,143,145,147,149,151,153,154,156,158,159,160,162,163,165,166],h.__kBitsPerCharTableShift=5,h.__kBitsPerCharTableMultiplier=1<<h.__kBitsPerCharTableShift,h.__kConversionChars=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"],h.__kBitConversionBuffer=new ArrayBuffer(8),h.__kBitConversionDouble=new Float64Array(h.__kBitConversionBuffer),h.__kBitConversionInts=new Int32Array(h.__kBitConversionBuffer),h.__clz30=Math.clz32?function(i){return Math.clz32(i)-2}:function(i){return i===0?30:0|29-(0|Math.log(i>>>0)/Math.LN2)},h.__imul=Math.imul||function(i,e){return 0|i*e};const Kr={};function Yt(i,e){Object.defineProperty(i.prototype,Symbol.toStringTag,{value:e,writable:!1,enumerable:!1,configurable:!0});for(const t of Object.getOwnPropertyNames(i)){const n=Object.getOwnPropertyDescriptor(i,t);n.configurable&&n.enumerable&&(n.enumerable=!1,Object.defineProperty(i,t,n))}for(const t of Object.getOwnPropertyNames(i.prototype)){const n=Object.getOwnPropertyDescriptor(i.prototype,t);n.configurable&&n.enumerable&&(n.enumerable=!1,Object.defineProperty(i.prototype,t,n))}Jr(e,i),Jr(`${e}.prototype`,i.prototype)}function Jr(i,e){const t=`%${i}%`;if(Kr[t]!==void 0)throw new Error(`intrinsic ${i} already exists`);Kr[t]=e}function x(i){return Kr[i]}const P="slot-epochNanoSeconds",Ut="slot-timezone-identifier",O="slot-year",$="slot-month",I="slot-day",Z="slot-hour",j="slot-minute",A="slot-second",q="slot-millisecond",U="slot-microsecond",S="slot-nanosecond",E="slot-calendar",qe="slot-cached-instant",ee="slot-time-zone",Se="slot-years",$e="slot-months",et="slot-weeks",ze="slot-days",Ge="slot-hours",He="slot-minutes",We="slot-seconds",Ve="slot-milliseconds",Be="slot-microseconds",Xe="slot-nanoseconds",De="slot-calendar-identifier",di=new WeakMap;function Nt(i){di.set(i,Object.create(null))}function yo(i){return di.get(i)}function Ye(i,...e){if(!i||typeof i!="object")return!1;const t=yo(i);return!!t&&e.reduce((n,r)=>n&&r in t,!0)}function o(i,e){const t=yo(i)[e];if(t===void 0)throw new TypeError(`Missing internal slot ${e}`);return t}function W(i,e,t){yo(i)[e]=t}const Ln=Array.prototype.includes,fs=Array.prototype.push,ys=globalThis.Intl.DateTimeFormat,gs=Array.prototype.sort,ws=Math.abs,ps=Math.floor,eo=Object.entries,Vo=Object.keys,ye={};class yr{constructor(e){if(arguments.length<1)throw new RangeError("missing argument: id is required");const t=L(e);if(!gi(t))throw new RangeError(`invalid calendar identifier ${t}`);Nt(this),W(this,De,t)}get id(){if(!be(this))throw new TypeError("invalid receiver");return L(this)}dateFromFields(e,t){if(!be(this))throw new TypeError("invalid receiver");if(!ue(e))throw new TypeError("invalid fields");const n=z(t);return ye[o(this,De)].dateFromFields(e,n,this)}yearMonthFromFields(e,t){if(!be(this))throw new TypeError("invalid receiver");if(!ue(e))throw new TypeError("invalid fields");const n=z(t);return ye[o(this,De)].yearMonthFromFields(e,n,this)}monthDayFromFields(e,t){if(!be(this))throw new TypeError("invalid receiver");if(!ue(e))throw new TypeError("invalid fields");const n=z(t);return ye[o(this,De)].monthDayFromFields(e,n,this)}fields(e){if(!be(this))throw new TypeError("invalid receiver");const t=[],n=new Set(["year","month","monthCode","day","hour","minute","second","millisecond","microsecond","nanosecond"]);for(const r of e){if(typeof r!="string")throw new TypeError("invalid fields");if(!n.has(r))throw new RangeError(`invalid field name ${r}`);n.delete(r),fs.call(t,r)}return ye[o(this,De)].fields(t)}mergeFields(e,t){if(!be(this))throw new TypeError("invalid receiver");return ye[o(this,De)].mergeFields(e,t)}dateAdd(e,t,n){if(!be(this))throw new TypeError("invalid receiver");const r=ce(e),s=gn(t),a=Le(z(n)),{days:c}=je(o(s,ze),o(s,Ge),o(s,He),o(s,We),o(s,Ve),o(s,Be),o(s,Xe),"day");return ye[o(this,De)].dateAdd(r,o(s,Se),o(s,$e),o(s,et),c,a,this)}dateUntil(e,t,n){if(!be(this))throw new TypeError("invalid receiver");const r=ce(e),s=ce(t),a=ut(z(n),"auto",["hour","minute","second","millisecond","microsecond","nanosecond"],"day"),{years:c,months:l,weeks:d,days:m}=ye[o(this,De)].dateUntil(r,s,a);return new(x("%Temporal.Duration%"))(c,l,d,m,0,0,0,0,0,0)}year(e){let t=e;if(!be(this))throw new TypeError("invalid receiver");return ne(t)||(t=ce(t)),ye[o(this,De)].year(t)}month(e){let t=e;if(!be(this))throw new TypeError("invalid receiver");if(Ne(t))throw new TypeError("use monthCode on PlainMonthDay instead");return ne(t)||(t=ce(t)),ye[o(this,De)].month(t)}monthCode(e){let t=e;if(!be(this))throw new TypeError("invalid receiver");return ne(t)||Ne(t)||(t=ce(t)),ye[o(this,De)].monthCode(t)}day(e){let t=e;if(!be(this))throw new TypeError("invalid receiver");return Ne(t)||(t=ce(t)),ye[o(this,De)].day(t)}era(e){let t=e;if(!be(this))throw new TypeError("invalid receiver");return ne(t)||(t=ce(t)),ye[o(this,De)].era(t)}eraYear(e){let t=e;if(!be(this))throw new TypeError("invalid receiver");return ne(t)||(t=ce(t)),ye[o(this,De)].eraYear(t)}dayOfWeek(e){if(!be(this))throw new TypeError("invalid receiver");const t=ce(e);return ye[o(this,De)].dayOfWeek(t)}dayOfYear(e){if(!be(this))throw new TypeError("invalid receiver");const t=ce(e);return ye[o(this,De)].dayOfYear(t)}weekOfYear(e){if(!be(this))throw new TypeError("invalid receiver");const t=ce(e);return ye[o(this,De)].weekOfYear(t)}daysInWeek(e){if(!be(this))throw new TypeError("invalid receiver");const t=ce(e);return ye[o(this,De)].daysInWeek(t)}daysInMonth(e){let t=e;if(!be(this))throw new TypeError("invalid receiver");return ne(t)||(t=ce(t)),ye[o(this,De)].daysInMonth(t)}daysInYear(e){let t=e;if(!be(this))throw new TypeError("invalid receiver");return ne(t)||(t=ce(t)),ye[o(this,De)].daysInYear(t)}monthsInYear(e){let t=e;if(!be(this))throw new TypeError("invalid receiver");return ne(t)||(t=ce(t)),ye[o(this,De)].monthsInYear(t)}inLeapYear(e){let t=e;if(!be(this))throw new TypeError("invalid receiver");return ne(t)||(t=ce(t)),ye[o(this,De)].inLeapYear(t)}toString(){if(!be(this))throw new TypeError("invalid receiver");return o(this,De)}toJSON(){if(!be(this))throw new TypeError("invalid receiver");return L(this)}static from(e){return Ae(e)}}function go(i){if(!i.startsWith("M"))throw new RangeError(`Invalid month code: ${i}.  Month codes must start with M.`);const e=+i.slice(1);if(isNaN(e))throw new RangeError(`Invalid month code: ${i}`);return e}function jt(i,e=!1){return`M${i.toString().padStart(2,"0")}${e?"L":""}`}function dr(i,e,t=12){let{month:n,monthCode:r}=i;if(r===void 0){if(n===void 0)throw new TypeError("Either month or monthCode are required");e==="reject"&&Ue(n,1,t),e==="constrain"&&(n=at(n,1,t)),r=jt(n)}else{const s=go(r);if(n!==void 0&&n!==s)throw new RangeError(`monthCode ${r} and month ${n} must match if both are present`);if(r!==jt(s))throw new RangeError(`Invalid month code: ${r}`);if(n=s,n<1||n>t)throw new RangeError(`Invalid monthCode: ${r}`)}return de(Q({},i),{month:n,monthCode:r})}Yt(yr,"Temporal.Calendar"),Jr("Temporal.Calendar.from",yr.from),ye.iso8601={dateFromFields(i,e,t){const n=Le(e);let r=Ze(i,[["day"],["month",void 0],["monthCode",void 0],["year"]]);r=dr(r);let{year:s,month:a,day:c}=r;return{year:s,month:a,day:c}=pr(s,a,c,n),Et(s,a,c,t)},yearMonthFromFields(i,e,t){const n=Le(e);let r=Ze(i,[["month",void 0],["monthCode",void 0],["year"]]);r=dr(r);let{year:s,month:a}=r;return{year:s,month:a}=function(l,d,m){let u=l,f=d;const y=1;switch(m){case"reject":$t(u,f,y);break;case"constrain":({year:u,month:f}=Vi(u,f))}return{year:u,month:f}}(s,a,n),Gn(s,a,t,1)},monthDayFromFields(i,e,t){const n=Le(e);let r=Ze(i,[["day"],["month",void 0],["monthCode",void 0],["year",void 0]]);if(r.month!==void 0&&r.year===void 0&&r.monthCode===void 0)throw new TypeError("either year or monthCode required with month");const s=r.monthCode===void 0;r=dr(r);let{month:a,day:c,year:l}=r;return{month:a,day:c}=pr(s?l:1972,a,c,n),zn(a,c,t,1972)},fields:i=>i,mergeFields(i,e){const t={};for(const r of Vo(i))r!=="month"&&r!=="monthCode"&&(t[r]=i[r]);const n=Vo(e);for(const r of n)t[r]=e[r];if(!Ln.call(n,"month")&&!Ln.call(n,"monthCode")){const{month:r,monthCode:s}=i;r!==void 0&&(t.month=r),s!==void 0&&(t.monthCode=s)}return t},dateAdd(i,e,t,n,r,s,a){let c=o(i,O),l=o(i,$),d=o(i,I);return{year:c,month:l,day:d}=nn(c,l,d,e,t,n,r,s),Et(c,l,d,a)},dateUntil:(i,e,t)=>ko(o(i,O),o(i,$),o(i,I),o(e,O),o(e,$),o(e,I),t),year:i=>o(i,O),era(){},eraYear(){},month:i=>o(i,$),monthCode:i=>jt(o(i,$)),day:i=>o(i,I),dayOfWeek:i=>Vr(o(i,O),o(i,$),o(i,I)),dayOfYear:i=>br(o(i,O),o(i,$),o(i,I)),weekOfYear:i=>function(t,n,r){const s=br(t,n,r),a=Vr(t,n,r)||7,c=Vr(t,1,1),l=Ie((s-a+10)/7);return l<1?c===5||c===6&&Gt(t-1)?53:52:l===53&&(Gt(t)?366:365)-s<4-a?1:l}(o(i,O),o(i,$),o(i,I)),daysInWeek:()=>7,daysInMonth:i=>qt(o(i,O),o(i,$)),daysInYear(i){let e=i;return Ye(e,O)||(e=ce(e)),Gt(o(e,O))?366:365},monthsInYear:()=>12,inLeapYear(i){let e=i;return Ye(e,O)||(e=ce(e)),Gt(o(e,O))}};class ge{constructor(e){if(this.map=new Map,this.calls=0,this.hits=0,this.misses=0,this.now=globalThis.performance?globalThis.performance.now():Date.now(),e!==void 0){let t=0;for(const n of e.map.entries()){if(++t>ge.MAX_CACHE_ENTRIES)break;this.map.set(...n)}}}get(e){const t=this.map.get(e);return t&&(this.hits++,this.report()),this.calls++,t}set(e,t){this.map.set(e,t),this.misses++,this.report()}report(){}setObject(e){if(ge.objectMap.get(e))throw new RangeError("object already cached");ge.objectMap.set(e,this),this.report()}static getCacheForObject(e){let t=ge.objectMap.get(e);return t||(t=new ge,ge.objectMap.set(e,t)),t}}function ui({isoYear:i,isoMonth:e,isoDay:t}){return`${hn(i)}-${fe(e)}-${fe(t)}T00:00Z`}function zr(i,e){return{years:i.year-e.year,months:i.month-e.month,days:i.day-e.day}}ge.objectMap=new WeakMap,ge.MAX_CACHE_ENTRIES=1e3;class Rn{constructor(){this.eraLength="short",this.hasEra=!0}getFormatter(){return this.formatter===void 0&&(this.formatter=new ys(`en-US-u-ca-${this.id}`,{day:"numeric",month:"numeric",year:"numeric",era:this.eraLength,timeZone:"UTC"})),this.formatter}isoToCalendarDate(e,t){const{year:n,month:r,day:s}=e,a=JSON.stringify({func:"isoToCalendarDate",isoYear:n,isoMonth:r,isoDay:s,id:this.id}),c=t.get(a);if(c)return c;const l=this.getFormatter();let d,m;try{m=ui({isoYear:n,isoMonth:r,isoDay:s}),d=l.formatToParts(new Date(m))}catch{throw new RangeError(`Invalid ISO date: ${JSON.stringify({isoYear:n,isoMonth:r,isoDay:s})}`)}const u={};for(let{type:y,value:g}of d){if(y==="year"&&(u.eraYear=+g),y==="relatedYear"&&(u.eraYear=+g),y==="month"){const w=/^([0-9]*)(.*?)$/.exec(g);if(!w||w.length!=3||!w[1]&&!w[2])throw new RangeError(`Unexpected month: ${g}`);if(u.month=w[1]?+w[1]:1,u.month<1)throw new RangeError(`Invalid month ${g} from ${m}[u-ca-${this.id}] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)`);if(u.month>13)throw new RangeError(`Invalid month ${g} from ${m}[u-ca-${this.id}] (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)`);w[2]&&(u.monthExtra=w[2])}y==="day"&&(u.day=+g),this.hasEra&&y==="era"&&g!=null&&g!==""&&(g=g.split(" (")[0],u.era=g.normalize("NFD").replace(/[^-0-9 \p{L}]/gu,"").replace(" ","-").toLowerCase())}if(u.eraYear===void 0)throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);if(this.reviseIntlEra){const{era:y,eraYear:g}=this.reviseIntlEra(u,e);u.era=y,u.eraYear=g}this.checkIcuBugs&&this.checkIcuBugs(e);const f=this.adjustCalendarDate(u,t,"constrain",!0);if(f.year===void 0)throw new RangeError(`Missing year converting ${JSON.stringify(e)}`);if(f.month===void 0)throw new RangeError(`Missing month converting ${JSON.stringify(e)}`);if(f.day===void 0)throw new RangeError(`Missing day converting ${JSON.stringify(e)}`);return t.set(a,f),["constrain","reject"].forEach(y=>{const g=JSON.stringify({func:"calendarToIsoDate",year:f.year,month:f.month,day:f.day,overflow:y,id:this.id});t.set(g,e)}),f}validateCalendarDate(e){const{era:t,month:n,year:r,day:s,eraYear:a,monthCode:c,monthExtra:l}=e;if(l!==void 0)throw new RangeError("Unexpected `monthExtra` value");if(r===void 0&&a===void 0)throw new TypeError("year or eraYear is required");if(n===void 0&&c===void 0)throw new TypeError("month or monthCode is required");if(s===void 0)throw new RangeError("Missing day");if(c!==void 0){if(typeof c!="string")throw new RangeError("monthCode must be a string, not "+typeof c);if(!/^M([01]?\d)(L?)$/.test(c))throw new RangeError(`Invalid monthCode: ${c}`)}if(this.constantEra){if(t!==void 0&&t!==this.constantEra)throw new RangeError(`era must be ${this.constantEra}, not ${t}`);if(a!==void 0&&r!==void 0&&a!==r)throw new RangeError(`eraYear ${a} does not match year ${r}`)}}adjustCalendarDate(e,t,n="constrain",r=!1){if(this.calendarType==="lunisolar")throw new RangeError("Override required for lunisolar calendars");let s=e;if(this.validateCalendarDate(s),this.constantEra){const{year:d,eraYear:m}=s;s=de(Q({},s),{era:this.constantEra,year:d!==void 0?d:m,eraYear:m!==void 0?m:d})}const a=this.monthsInYear(s,t);let{month:c,monthCode:l}=s;return{month:c,monthCode:l}=dr(s,n,a),de(Q({},s),{month:c,monthCode:l})}regulateMonthDayNaive(e,t,n){const r=this.monthsInYear(e,n);let{month:s,day:a}=e;return t==="reject"?(Ue(s,1,r),Ue(a,1,this.maximumMonthLength(e))):(s=at(s,1,r),a=at(a,1,this.maximumMonthLength(de(Q({},e),{month:s})))),de(Q({},e),{month:s,day:a})}calendarToIsoDate(e,t="constrain",n){const r=e;let s=this.adjustCalendarDate(e,n,t,!1);s=this.regulateMonthDayNaive(s,t,n);const{year:a,month:c,day:l}=s,d=JSON.stringify({func:"calendarToIsoDate",year:a,month:c,day:l,overflow:t,id:this.id});let m,u=n.get(d);if(u||r.year!==void 0&&r.month!==void 0&&r.day!==void 0&&(r.year!==s.year||r.month!==s.month||r.day!==s.day)&&(m=JSON.stringify({func:"calendarToIsoDate",year:r.year,month:r.month,day:r.day,overflow:t,id:this.id}),u=n.get(m),u))return u;let f=this.estimateIsoDate({year:a,month:c,day:l});const y=b=>{let D=this.addDaysIso(f,b);if(s.day>this.minimumMonthLength(s)){let _=this.isoToCalendarDate(D,n);for(;_.month!==c||_.year!==a;){if(t==="reject")throw new RangeError(`day ${l} does not exist in month ${c} of year ${a}`);D=this.addDaysIso(D,-1),_=this.isoToCalendarDate(D,n)}}return D};let g=0,w=this.isoToCalendarDate(f,n),p=zr(s,w);if(p.years!==0||p.months!==0||p.days!==0){const b=365*p.years+30*p.months+p.days;f=this.addDaysIso(f,b),w=this.isoToCalendarDate(f,n),p=zr(s,w),p.years===0&&p.months===0?f=y(p.days):g=this.compareCalendarDates(s,w)}let v=8,T=!1;for(;g;){f=this.addDaysIso(f,g*v);const b=w;w=this.isoToCalendarDate(f,n);const D=g;if(g=this.compareCalendarDates(s,w),g){if(p=zr(s,w),p.years===0&&p.months===0)f=y(p.days),g=0,T=s.day>this.minimumMonthLength(s);else if(D&&g!==D)if(v>1)v/=2;else{if(t==="reject")throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify(Q({},r))}`);this.compareCalendarDates(w,b)>0&&(f=this.addDaysIso(f,-1)),T=!0,g=0}}}if(n.set(d,f),m&&n.set(m,f),s.year===void 0||s.month===void 0||s.day===void 0||s.monthCode===void 0||this.hasEra&&(s.era===void 0||s.eraYear===void 0))throw new RangeError("Unexpected missing property");if(!T){const b=JSON.stringify({func:"isoToCalendarDate",isoYear:f.year,isoMonth:f.month,isoDay:f.day,id:this.id});n.set(b,s)}return f}temporalToCalendarDate(e,t){const n={year:o(e,O),month:o(e,$),day:o(e,I)};return this.isoToCalendarDate(n,t)}compareCalendarDates(e,t){const n=Ze(e,[["day"],["month"],["year"]]),r=Ze(t,[["day"],["month"],["year"]]);return n.year!==r.year?rn(n.year-r.year):n.month!==r.month?rn(n.month-r.month):n.day!==r.day?rn(n.day-r.day):0}regulateDate(e,t="constrain",n){const r=this.calendarToIsoDate(e,t,n);return this.isoToCalendarDate(r,n)}addDaysIso(e,t){return nn(e.year,e.month,e.day,0,0,0,t,"constrain")}addDaysCalendar(e,t,n){const r=this.calendarToIsoDate(e,"constrain",n),s=this.addDaysIso(r,t);return this.isoToCalendarDate(s,n)}addMonthsCalendar(e,t,n,r){let s=e;const{day:a}=s;for(let c=0,l=ws(t);c<l;c++){const{month:d}=s,m=s,u=t<0?-Math.max(a,this.daysInPreviousMonth(s,r)):this.daysInMonth(s,r),f=this.calendarToIsoDate(s,"constrain",r);let y=this.addDaysIso(f,u);if(s=this.isoToCalendarDate(y,r),t>0){const g=this.monthsInYear(m,r);for(;s.month-1!=d%g;)y=this.addDaysIso(y,-1),s=this.isoToCalendarDate(y,r)}s.day!==a&&(s=this.regulateDate(de(Q({},s),{day:a}),"constrain",r))}if(n==="reject"&&s.day!==a)throw new RangeError(`Day ${a} does not exist in resulting calendar month`);return s}addCalendar(e,{years:t=0,months:n=0,weeks:r=0,days:s=0},a,c){const{year:l,month:d,day:m}=e,u=this.addMonthsCalendar({year:l+t,month:d,day:m},n,a,c),f=s+7*r;return this.addDaysCalendar(u,f,c)}untilCalendar(e,t,n,r){let s=0,a=0,c=0,l=0;switch(n){case"day":s=this.calendarDaysUntil(e,t,r);break;case"week":{const d=this.calendarDaysUntil(e,t,r);s=d%7,a=(d-s)/7;break}case"month":case"year":{const d=t.year-e.year,m=t.month-e.month,u=t.day-e.day,f=this.compareCalendarDates(t,e);n==="year"&&d&&(l=m*f<0||m===0&&u*f<0?d-f:d);let y,g=l?this.addCalendar(e,{years:l},"constrain",r):e;do c+=f,y=g,g=this.addMonthsCalendar(y,f,"constrain",r),g.day!==e.day&&(g=this.regulateDate(de(Q({},g),{day:e.day}),"constrain",r));while(this.compareCalendarDates(t,g)*f>=0);c-=f,s=this.calendarDaysUntil(y,t,r);break}}return{years:l,months:c,weeks:a,days:s}}daysInMonth(e,t){const{day:n}=e,r=this.maximumMonthLength(e),s=this.minimumMonthLength(e);if(s===r)return s;const a=n<=r-s?r:s,c=this.calendarToIsoDate(e,"constrain",t),l=this.addDaysIso(c,a),d=this.isoToCalendarDate(l,t),m=this.addDaysIso(l,-d.day);return this.isoToCalendarDate(m,t).day}daysInPreviousMonth(e,t){const{day:n,month:r,year:s}=e;let a={year:r>1?s:s-1,month:r,day:1};const c=r>1?r-1:this.monthsInYear(a,t);a=de(Q({},a),{month:c});const l=this.minimumMonthLength(a),d=this.maximumMonthLength(a);if(l===d)return d;const m=this.calendarToIsoDate(e,"constrain",t),u=this.addDaysIso(m,-n);return this.isoToCalendarDate(u,t).day}startOfCalendarYear(e){return{year:e.year,month:1,day:1}}startOfCalendarMonth(e){return{year:e.year,month:e.month,day:1}}calendarDaysUntil(e,t,n){const r=this.calendarToIsoDate(e,"constrain",n),s=this.calendarToIsoDate(t,"constrain",n);return this.isoDaysUntil(r,s)}isoDaysUntil(e,t){return ko(e.year,e.month,e.day,t.year,t.month,t.day,"day").days}monthDayFromFields(e,t,n){let r,s,a,c,l,{year:d,month:m,monthCode:u,day:f,era:y,eraYear:g}=e;if(u===void 0){if(d===void 0&&(y===void 0||g===void 0))throw new TypeError("`monthCode`, `year`, or `era` and `eraYear` is required");({monthCode:u,year:d}=this.adjustCalendarDate({year:d,month:m,monthCode:u,day:f,era:y,eraYear:g},n,t))}const{year:w}=this.isoToCalendarDate({year:1972,month:1,day:1},n);for(let p=0;p<100;p++){const v=this.adjustCalendarDate({day:f,monthCode:u,year:w-p},n),T=this.calendarToIsoDate(v,"constrain",n),b=this.isoToCalendarDate(T,n);if({year:r,month:s,day:a}=T,b.monthCode===u&&b.day===f)return{month:s,day:a,year:r};t==="constrain"&&(c===void 0||b.monthCode===c.monthCode&&b.day>c.day)&&(c=b,l=T)}if(t==="constrain"&&l!==void 0)return l;throw new RangeError(`No recent ${this.id} year with monthCode ${u} and day ${f}`)}}class vs extends Rn{constructor(){super(...arguments),this.id="hebrew",this.calendarType="lunisolar",this.months={Tishri:{leap:1,regular:1,monthCode:"M01",days:30},Heshvan:{leap:2,regular:2,monthCode:"M02",days:{min:29,max:30}},Kislev:{leap:3,regular:3,monthCode:"M03",days:{min:29,max:30}},Tevet:{leap:4,regular:4,monthCode:"M04",days:29},Shevat:{leap:5,regular:5,monthCode:"M05",days:30},Adar:{leap:void 0,regular:6,monthCode:"M06",days:29},"Adar I":{leap:6,regular:void 0,monthCode:"M05L",days:30},"Adar II":{leap:7,regular:void 0,monthCode:"M06",days:29},Nisan:{leap:8,regular:7,monthCode:"M07",days:30},Iyar:{leap:9,regular:8,monthCode:"M08",days:29},Sivan:{leap:10,regular:9,monthCode:"M09",days:30},Tamuz:{leap:11,regular:10,monthCode:"M10",days:29},Av:{leap:12,regular:11,monthCode:"M11",days:30},Elul:{leap:13,regular:12,monthCode:"M12",days:29}},this.hasEra=!1}inLeapYear(e){const{year:t}=e;return(7*t+1)%19<7}monthsInYear(e){return this.inLeapYear(e)?13:12}minimumMonthLength(e){return this.minMaxMonthLength(e,"min")}maximumMonthLength(e){return this.minMaxMonthLength(e,"max")}minMaxMonthLength(e,t){const{month:n,year:r}=e,s=this.getMonthCode(r,n),a=eo(this.months).find(l=>l[1].monthCode===s);if(a===void 0)throw new RangeError(`unmatched Hebrew month: ${n}`);const c=a[1].days;return typeof c=="number"?c:c[t]}estimateIsoDate(e){const{year:t}=e;return{year:t-3760,month:1,day:1}}getMonthCode(e,t){return this.inLeapYear({year:e})?t===6?jt(5,!0):jt(t<6?t:t-1):jt(t)}adjustCalendarDate(e,t,n="constrain",r=!1){let{year:s,eraYear:a,month:c,monthCode:l,day:d,monthExtra:m}=e;if(s===void 0&&a!==void 0&&(s=a),a===void 0&&s!==void 0&&(a=s),r){if(m){const u=this.months[m];if(!u)throw new RangeError(`Unrecognized month from formatToParts: ${m}`);c=this.inLeapYear({year:s})?u.leap:u.regular}return l=this.getMonthCode(s,c),{year:s,month:c,day:d,era:void 0,eraYear:a,monthCode:l}}if(this.validateCalendarDate(e),c===void 0)if(l.endsWith("L")){if(l!=="M05L")throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${l}`);if(c=6,!this.inLeapYear({year:s})){if(n==="reject")throw new RangeError(`Hebrew monthCode M05L is invalid in year ${s} which is not a leap year`);c=5,d=30,l="M05"}}else{c=go(l),this.inLeapYear({year:s})&&c>6&&c++;const u=this.monthsInYear({year:s});if(c<1||c>u)throw new RangeError(`Invalid monthCode: ${l}`)}else if(n==="reject"?(Ue(c,1,this.monthsInYear({year:s})),Ue(d,1,this.maximumMonthLength({year:s,month:c}))):(c=at(c,1,this.monthsInYear({year:s})),d=at(d,1,this.maximumMonthLength({year:s,month:c}))),l===void 0)l=this.getMonthCode(s,c);else if(this.getMonthCode(s,c)!==l)throw new RangeError(`monthCode ${l} doesn't correspond to month ${c} in Hebrew year ${s}`);return de(Q({},e),{day:d,month:c,monthCode:l,year:s,eraYear:a})}}class On extends Rn{constructor(){super(...arguments),this.calendarType="lunar",this.DAYS_PER_ISLAMIC_YEAR=354+11/30,this.DAYS_PER_ISO_YEAR=365.2425,this.constantEra="ah"}inLeapYear(e,t){return this.daysInMonth({year:e.year,month:12,day:1},t)===30}monthsInYear(){return 12}minimumMonthLength(){return 29}maximumMonthLength(){return 30}estimateIsoDate(e){const{year:t}=this.adjustCalendarDate(e);return{year:ps(t*this.DAYS_PER_ISLAMIC_YEAR/this.DAYS_PER_ISO_YEAR)+622,month:1,day:1}}}class mi extends On{constructor(){super(...arguments),this.id="islamic"}}class Ts extends On{constructor(){super(...arguments),this.id="islamic-umalqura"}}class Es extends On{constructor(){super(...arguments),this.id="islamic-tbla"}}class bs extends On{constructor(){super(...arguments),this.id="islamic-civil"}}class Ds extends On{constructor(){super(...arguments),this.id="islamic-rgsa"}}class _s extends On{constructor(){super(...arguments),this.id="islamicc"}}class Cs extends Rn{constructor(){super(...arguments),this.id="persian",this.calendarType="solar",this.constantEra="ap"}inLeapYear(e,t){return mi.prototype.inLeapYear.call(this,e,t)}monthsInYear(){return 12}minimumMonthLength(e){const{month:t}=e;return t===12?29:t<=6?31:30}maximumMonthLength(e){const{month:t}=e;return t===12?30:t<=6?31:30}estimateIsoDate(e){const{year:t}=this.adjustCalendarDate(e);return{year:t+621,month:1,day:1}}}class Ms extends Rn{constructor(){super(...arguments),this.id="indian",this.calendarType="solar",this.constantEra="saka",this.months={1:{length:30,month:3,day:22,leap:{length:31,month:3,day:21}},2:{length:31,month:4,day:21},3:{length:31,month:5,day:22},4:{length:31,month:6,day:22},5:{length:31,month:7,day:23},6:{length:31,month:8,day:23},7:{length:30,month:9,day:23},8:{length:30,month:10,day:23},9:{length:30,month:11,day:22},10:{length:30,month:12,day:22},11:{length:30,month:1,nextYear:!0,day:21},12:{length:30,month:2,nextYear:!0,day:20}},this.vulnerableToBceBug=new Date("0000-01-01T00:00Z").toLocaleDateString("en-US-u-ca-indian",{timeZone:"UTC"})!=="10/11/-79 Saka"}inLeapYear(e){return fi(e.year+78)}monthsInYear(){return 12}minimumMonthLength(e){return this.getMonthInfo(e).length}maximumMonthLength(e){return this.getMonthInfo(e).length}getMonthInfo(e){const{month:t}=e;let n=this.months[t];if(n===void 0)throw new RangeError(`Invalid month: ${t}`);return this.inLeapYear(e)&&n.leap&&(n=n.leap),n}estimateIsoDate(e){const t=this.adjustCalendarDate(e),n=this.getMonthInfo(t);return nn(t.year+78+(n.nextYear?1:0),n.month,n.day,0,0,0,t.day-1,"constrain")}checkIcuBugs(e){if(this.vulnerableToBceBug&&e.year<1)throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 0001-01-01 (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)`)}}function fi(i){return i%4==0&&(i%100!=0||i%400==0)}class Vn extends Rn{constructor(e,t){super(),this.calendarType="solar",this.v8IsVulnerableToJulianBug=new Date("+001001-01-01T00:00Z").toLocaleDateString("en-US-u-ca-japanese",{timeZone:"UTC"}).startsWith("12"),this.calendarIsVulnerableToJulianBug=!1,this.id=e;const{eras:n,anchorEra:r}=function(a){let c,l=a;if(l.length===0)throw new RangeError("Invalid era data: eras are required");if(l.length===1&&l[0].reverseOf)throw new RangeError("Invalid era data: anchor era cannot count years backwards");if(l.length===1&&!l[0].name)throw new RangeError("Invalid era data: at least one named era is required");if(l.filter(m=>m.reverseOf!=null).length>1)throw new RangeError("Invalid era data: only one era can count years backwards");l.forEach(m=>{if(m.isAnchor||!m.anchorEpoch&&!m.reverseOf){if(c)throw new RangeError("Invalid era data: cannot have multiple anchor eras");c=m,m.anchorEpoch={year:m.hasYearZero?0:1}}else if(!m.name)throw new RangeError("If era name is blank, it must be the anchor era")}),l=l.filter(m=>m.name),l.forEach(m=>{const{reverseOf:u}=m;if(u){const f=l.find(y=>y.name===u);if(f===void 0)throw new RangeError(`Invalid era data: unmatched reverseOf era: ${u}`);m.reverseOf=f,m.anchorEpoch=f.anchorEpoch,m.isoEpoch=f.isoEpoch}m.anchorEpoch.month===void 0&&(m.anchorEpoch.month=1),m.anchorEpoch.day===void 0&&(m.anchorEpoch.day=1)}),gs.call(l,(m,u)=>{if(m.reverseOf)return 1;if(u.reverseOf)return-1;if(!m.isoEpoch||!u.isoEpoch)throw new RangeError("Invalid era data: missing ISO epoch");return u.isoEpoch.year-m.isoEpoch.year});const d=l[l.length-1].reverseOf;if(d&&d!==l[l.length-2])throw new RangeError("Invalid era data: invalid reverse-sign era");return l.forEach((m,u)=>{m.genericName="era"+(l.length-1-u)}),{eras:l,anchorEra:c||l[0]}}(t);this.anchorEra=r,this.eras=n}inLeapYear(e){const{year:t}=this.estimateIsoDate({month:1,day:1,year:e.year});return fi(t)}monthsInYear(){return 12}minimumMonthLength(e){const{month:t}=e;return t===2?this.inLeapYear(e)?29:28:[4,6,9,11].indexOf(t)>=0?30:31}maximumMonthLength(e){return this.minimumMonthLength(e)}completeEraYear(e){const t=(c,l)=>{const d=e[c];if(d!=null&&d!=l)throw new RangeError(`Input ${c} ${d} doesn't match calculated value ${l}`)},n=c=>{let l;const d=de(Q({},e),{year:c}),m=this.eras.find((u,f)=>{if(f===this.eras.length-1){if(u.reverseOf){if(c>0)throw new RangeError(`Signed year ${c} is invalid for era ${u.name}`);return l=u.anchorEpoch.year-c,!0}return l=c-u.anchorEpoch.year+(u.hasYearZero?0:1),!0}return this.compareCalendarDates(d,u.anchorEpoch)>=0&&(l=c-u.anchorEpoch.year+(u.hasYearZero?0:1),!0)});if(!m)throw new RangeError(`Year ${c} was not matched by any era`);return{eraYear:l,era:m.name}};let{year:r,eraYear:s,era:a}=e;if(r!=null)({eraYear:s,era:a}=n(r)),t("era",a),t("eraYear",s);else{if(s==null)throw new RangeError("Either `year` or `eraYear` and `era` are required");{const c=a===void 0?void 0:this.eras.find(l=>l.name===a||l.genericName===a);if(!c)throw new RangeError(`Era ${a} (ISO year ${s}) was not matched by any era`);if(s<1&&c.reverseOf)throw new RangeError(`Years in ${a} era must be positive, not ${r}`);r=c.reverseOf?c.anchorEpoch.year-s:s+c.anchorEpoch.year-(c.hasYearZero?0:1),t("year",r),{eraYear:s,era:a}=n(r)}}return de(Q({},e),{year:r,eraYear:s,era:a})}adjustCalendarDate(e,t,n="constrain"){let r=e;const{month:s,monthCode:a}=r;return s===void 0&&(r=de(Q({},r),{month:go(a)})),this.validateCalendarDate(r),r=this.completeEraYear(r),super.adjustCalendarDate(r,t,n)}estimateIsoDate(e){const t=this.adjustCalendarDate(e),{year:n,month:r,day:s}=t,{anchorEra:a}=this;return pr(n+a.isoEpoch.year-(a.hasYearZero?0:1),r,s,"constrain")}checkIcuBugs(e){if(this.calendarIsVulnerableToJulianBug&&this.v8IsVulnerableToJulianBug&&Lt(e.year,e.month,e.day,1582,10,15)<0)throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 1582-10-15 (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)`)}}class wo extends Vn{constructor(e,t){super(e,t)}inLeapYear(e){const{year:t}=e;return(t+1)%4==0}monthsInYear(){return 13}minimumMonthLength(e){const{month:t}=e;return t===13?this.inLeapYear(e)?6:5:30}maximumMonthLength(e){return this.minimumMonthLength(e)}}class Rs extends wo{constructor(){super("ethioaa",[{name:"era0",isoEpoch:{year:-5492,month:7,day:17}}])}}class Os extends wo{constructor(){super("coptic",[{name:"era1",isoEpoch:{year:284,month:8,day:29}},{name:"era0",reverseOf:"era1"}])}}class $s extends wo{constructor(){super("ethiopic",[{name:"era0",isoEpoch:{year:-5492,month:7,day:17}},{name:"era1",isoEpoch:{year:8,month:8,day:27},anchorEpoch:{year:5501}}])}}class ks extends Vn{constructor(){super("roc",[{name:"minguo",isoEpoch:{year:1912,month:1,day:1}},{name:"before-roc",reverseOf:"minguo"}]),this.calendarIsVulnerableToJulianBug=!0}}class Is extends Vn{constructor(){super("buddhist",[{name:"be",hasYearZero:!0,isoEpoch:{year:-543,month:1,day:1}}]),this.calendarIsVulnerableToJulianBug=!0}}class Ys extends Vn{constructor(){super("gregory",[{name:"ce",isoEpoch:{year:1,month:1,day:1}},{name:"bce",reverseOf:"ce"}])}reviseIntlEra(e){let{era:t,eraYear:n}=e;return t!=="bc"&&t!=="b"||(t="bce"),t!=="ad"&&t!=="a"||(t="ce"),{era:t,eraYear:n}}}class Ns extends Vn{constructor(){super("japanese",[{name:"reiwa",isoEpoch:{year:2019,month:5,day:1},anchorEpoch:{year:2019,month:5,day:1}},{name:"heisei",isoEpoch:{year:1989,month:1,day:8},anchorEpoch:{year:1989,month:1,day:8}},{name:"showa",isoEpoch:{year:1926,month:12,day:25},anchorEpoch:{year:1926,month:12,day:25}},{name:"taisho",isoEpoch:{year:1912,month:7,day:30},anchorEpoch:{year:1912,month:7,day:30}},{name:"meiji",isoEpoch:{year:1868,month:9,day:8},anchorEpoch:{year:1868,month:9,day:8}},{name:"ce",isoEpoch:{year:1,month:1,day:1}},{name:"bce",reverseOf:"ce"}]),this.calendarIsVulnerableToJulianBug=!0,this.eraLength="long"}reviseIntlEra(e,t){const{era:n,eraYear:r}=e,{year:s}=t;return this.eras.find(a=>a.name===n)?{era:n,eraYear:r}:s<1?{era:"bce",eraYear:1-s}:{era:"ce",eraYear:s}}}class yi extends Rn{constructor(){super(...arguments),this.calendarType="lunisolar",this.hasEra=!1}inLeapYear(e,t){const n=this.getMonthList(e.year,t);return eo(n).length===13}monthsInYear(e,t){return this.inLeapYear(e,t)?13:12}minimumMonthLength(){return 29}maximumMonthLength(){return 30}getMonthList(e,t){if(e===void 0)throw new TypeError("Missing year");const n=JSON.stringify({func:"getMonthList",calendarYear:e,id:this.id}),r=t.get(n);if(r)return r;const s=this.getFormatter(),a=(p,v)=>{const T=ui({isoYear:p,isoMonth:2,isoDay:1}),b=new Date(T);b.setUTCDate(v+1);const D=s.formatToParts(b),_=D.find(k=>k.type==="month").value,C=+D.find(k=>k.type==="day").value;let M=D.find(k=>k.type==="relatedYear");if(M===void 0)throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);return M=+M.value,{calendarMonthString:_,calendarDay:C,calendarYearToVerify:M}};let c=17,{calendarMonthString:l,calendarDay:d,calendarYearToVerify:m}=a(e,c);l!=="1"&&(c+=29,{calendarMonthString:l,calendarDay:d}=a(e,c)),c-=d-5;const u={};let f,y,g=1,w=!1;do({calendarMonthString:l,calendarDay:d,calendarYearToVerify:m}=a(e,c)),f&&(u[y].daysInMonth=f+30-d),m!==e?w=!0:(u[l]={monthIndex:g++},c+=30),f=d,y=l;while(!w);return u[y].daysInMonth=f+30-d,t.set(n,u),u}estimateIsoDate(e){const{year:t,month:n}=e;return{year:t,month:n>=12?12:n+1,day:1}}adjustCalendarDate(e,t,n="constrain",r=!1){let{year:s,month:a,monthExtra:c,day:l,monthCode:d,eraYear:m}=e;if(r){if(s=m,c&&c!=="bis")throw new RangeError(`Unexpected leap month suffix: ${c}`);const u=jt(a,c!==void 0),f=`${a}${c||""}`,y=this.getMonthList(s,t)[f];if(y===void 0)throw new RangeError(`Unmatched month ${f} in Chinese year ${s}`);return a=y.monthIndex,{year:s,month:a,day:l,era:void 0,eraYear:m,monthCode:u}}if(this.validateCalendarDate(e),s===void 0&&(s=m),m===void 0&&(m=s),a===void 0){const u=this.getMonthList(s,t);let f=d.replace("L","bis").slice(1);f[0]==="0"&&(f=f.slice(1));let y=u[f];if(a=y&&y.monthIndex,a===void 0&&d.endsWith("L")&&!Ln.call(["M01L","M12L","M13L"],d)&&n==="constrain"){let g=d.slice(1,-1);g[0]==="0"&&(g=g.slice(1)),y=u[g],y&&({daysInMonth:l,monthIndex:a}=y,d=jt(g))}if(a===void 0)throw new RangeError(`Unmatched month ${d} in Chinese year ${s}`)}else if(d===void 0){const u=this.getMonthList(s,t),f=eo(u),y=f.length;n==="reject"?(Ue(a,1,y),Ue(l,1,this.maximumMonthLength())):(a=at(a,1,y),l=at(l,1,this.maximumMonthLength()));const g=f.find(([,w])=>w.monthIndex===a);if(g===void 0)throw new RangeError(`Invalid month ${a} in Chinese year ${s}`);d=jt(g[0].replace("bis",""),g[0].indexOf("bis")!==-1)}else{const u=this.getMonthList(s,t);let f=d.replace("L","bis").slice(1);f[0]==="0"&&(f=f.slice(1));const y=u[f];if(!y)throw new RangeError(`Unmatched monthCode ${d} in Chinese year ${s}`);if(a!==y.monthIndex)throw new RangeError(`monthCode ${d} doesn't correspond to month ${a} in Chinese year ${s}`)}return de(Q({},e),{year:s,eraYear:m,month:a,monthCode:d,day:l})}}class Ps extends yi{constructor(){super(...arguments),this.id="chinese"}}class Fs extends yi{constructor(){super(...arguments),this.id="dangi"}}const xs={helper:void 0,dateFromFields(i,e,t){const n=Le(e),r=new ge,s=Ze(i,[["day"],["era",void 0],["eraYear",void 0],["month",void 0],["monthCode",void 0],["year",void 0]]),{year:a,month:c,day:l}=this.helper.calendarToIsoDate(s,n,r),d=Et(a,c,l,t);return r.setObject(d),d},yearMonthFromFields(i,e,t){const n=Le(e),r=new ge,s=Ze(i,[["era",void 0],["eraYear",void 0],["month",void 0],["monthCode",void 0],["year",void 0]]),{year:a,month:c,day:l}=this.helper.calendarToIsoDate(de(Q({},s),{day:1}),n,r),d=Gn(a,c,t,l);return r.setObject(d),d},monthDayFromFields(i,e,t){const n=Le(e),r=new ge,s=Ze(i,[["day"],["era",void 0],["eraYear",void 0],["month",void 0],["monthCode",void 0],["year",void 0]]),{year:a,month:c,day:l}=this.helper.monthDayFromFields(s,n,r),d=zn(c,l,t,a);return r.setObject(d),d},fields(i){let e=i;return Ln.call(e,"year")&&(e=[...e,"era","eraYear"]),e},mergeFields(i,e){const t=Q({},i),n=Q({},e),w=t,{month:r,monthCode:s,year:a,era:c,eraYear:l}=w,d=Wo(w,["month","monthCode","year","era","eraYear"]),{month:m,monthCode:u,year:f,era:y,eraYear:g}=n;return m===void 0&&u===void 0&&(d.month=r,d.monthCode=s),f===void 0&&y===void 0&&g===void 0&&(d.year=a),Q(Q({},d),n)},dateAdd(i,e,t,n,r,s,a){const c=ge.getCacheForObject(i),l=this.helper.temporalToCalendarDate(i,c),d=this.helper.addCalendar(l,{years:e,months:t,weeks:n,days:r},s,c),m=this.helper.calendarToIsoDate(d,"constrain",c),{year:u,month:f,day:y}=m,g=Et(u,f,y,a);return new ge(c).setObject(g),g},dateUntil(i,e,t){const n=ge.getCacheForObject(i),r=ge.getCacheForObject(e),s=this.helper.temporalToCalendarDate(i,n),a=this.helper.temporalToCalendarDate(e,r);return this.helper.untilCalendar(s,a,t,n)},year(i){const e=ge.getCacheForObject(i);return this.helper.temporalToCalendarDate(i,e).year},month(i){const e=ge.getCacheForObject(i);return this.helper.temporalToCalendarDate(i,e).month},day(i){const e=ge.getCacheForObject(i);return this.helper.temporalToCalendarDate(i,e).day},era(i){if(!this.helper.hasEra)return;const e=ge.getCacheForObject(i);return this.helper.temporalToCalendarDate(i,e).era},eraYear(i){if(!this.helper.hasEra)return;const e=ge.getCacheForObject(i);return this.helper.temporalToCalendarDate(i,e).eraYear},monthCode(i){const e=ge.getCacheForObject(i);return this.helper.temporalToCalendarDate(i,e).monthCode},dayOfWeek:i=>ye.iso8601.dayOfWeek(i),dayOfYear(i){const e=ge.getCacheForObject(i),t=this.helper.isoToCalendarDate(i,e),n=this.helper.startOfCalendarYear(t);return this.helper.calendarDaysUntil(n,t,e)+1},weekOfYear:i=>ye.iso8601.weekOfYear(i),daysInWeek:i=>ye.iso8601.daysInWeek(i),daysInMonth(i){const e=ge.getCacheForObject(i),t=this.helper.temporalToCalendarDate(i,e),n=this.helper.maximumMonthLength(t);if(n===this.helper.minimumMonthLength(t))return n;const r=this.helper.startOfCalendarMonth(t),s=this.helper.addMonthsCalendar(r,1,"constrain",e);return this.helper.calendarDaysUntil(r,s,e)},daysInYear(i){let e=i;Ye(e,O)||(e=ce(e));const t=ge.getCacheForObject(e),n=this.helper.temporalToCalendarDate(e,t),r=this.helper.startOfCalendarYear(n),s=this.helper.addCalendar(r,{years:1},"constrain",t);return this.helper.calendarDaysUntil(r,s,t)},monthsInYear(i){const e=ge.getCacheForObject(i),t=this.helper.temporalToCalendarDate(i,e);return this.helper.monthsInYear(t,e)},inLeapYear(i){let e=i;Ye(e,O)||(e=ce(e));const t=ge.getCacheForObject(e),n=this.helper.temporalToCalendarDate(e,t);return this.helper.inLeapYear(n,t)}};for(const i of[vs,Cs,$s,Rs,Os,Ps,Fs,ks,Ms,Is,Ys,Ns,mi,Ts,Es,bs,Ds,_s]){const e=new i;ye[e.id]=de(Q({},xs),{helper:e})}const Ls=Object.keys(ye);function gi(i){return Ln.call(Ls,i)}const Bo=/\.[-A-Za-z_]|\.\.[-A-Za-z._]{1,12}|\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/,Zs=new RegExp(`(?:(?:${Bo.source})(?:\\/(?:${Bo.source}))*|Etc/GMT[-+]\\d{1,2}|${/(?:[+\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\d{1,9})?)?)?)/.source})`),Xo=/[A-Za-z0-9]{3,8}/,js=new RegExp(`(?:${Xo.source}(?:-${Xo.source})*)`),wi=/(?:[+\u2212-]\d{6}|\d{4})/,gr=/(?:0[1-9]|1[0-2])/,to=/(?:0[1-9]|[12]\d|3[01])/,As=new RegExp(`(${wi.source})(?:-(${gr.source})-(${to.source})|(${gr.source})(${to.source}))`),pi=/(\d{2})(?::(\d{2})(?::(\d{2})(?:[.,](\d{1,9}))?)?|(\d{2})(?:(\d{2})(?:[.,](\d{1,9}))?)?)?/,vi=/([+\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\d{1,9}))?)?)?/,Ti=new RegExp(`(?:([zZ])|(?:${vi.source})?)(?:\\[(${Zs.source})\\])?`),Ei=new RegExp(`\\[u-ca=(${js.source})\\]`),qs=new RegExp(`^${As.source}(?:(?:T|\\s+)${pi.source})?${Ti.source}(?:${Ei.source})?$`,"i"),Us=new RegExp(`^T?${pi.source}(?:${Ti.source})?(?:${Ei.source})?$`,"i"),Ss=new RegExp(`^(${wi.source})-?(${gr.source})$`),zs=new RegExp(`^(?:--)?(${gr.source})-?(${to.source})$`),Gr=/(\d+)(?:[.,](\d{1,9}))?/,Gs=new RegExp(`(?:${Gr.source}H)?(?:${Gr.source}M)?(?:${Gr.source}S)?`),Hs=new RegExp(`^([+\u2212-])?P${/(?:(\d+)Y)?(?:(\d+)M)?(?:(\d+)W)?(?:(\d+)D)?/.source}(?:T(?!$)${Gs.source})?$`,"i"),bi=Array.prototype.push,Di=globalThis.Intl.DateTimeFormat,Ws=Math.min,Vs=Math.max,te=Math.abs,Ie=Math.floor,Zn=Math.sign,fn=Math.trunc,Bn=Number.isNaN,xe=Number.isFinite,Bs=Number,Xn=String,Xs=Number.MAX_SAFE_INTEGER,le=Object.create,Qs=Object.is,po=Reflect.apply,_e=h.BigInt(0),vo=h.BigInt(1),Jt=h.BigInt(60),oe=h.BigInt(1e3),lt=h.BigInt(1e6),At=h.BigInt(1e9),Ks=h.BigInt(-1),Wt=h.multiply(h.BigInt(86400),At),jn=h.multiply(h.BigInt(-86400),h.BigInt(1e17)),An=h.multiply(h.BigInt(86400),h.BigInt(1e17)),_i=h.multiply(h.BigInt(-388152),h.BigInt(1e13)),Js=h.multiply(Wt,h.BigInt(3660)),Ci=h.multiply(Wt,h.BigInt(366)),Mi=h.multiply(Wt,h.BigInt(14));function Ri(i){if(typeof i!="number"||!xe(i))return!1;const e=te(i);return Ie(e)===e}function ue(i){return typeof i=="object"&&i!==null||typeof i=="function"}function qn(i){if(typeof i=="bigint")throw new TypeError("Cannot convert BigInt to number");return Bs(i)}function ie(i){const e=qn(i);if(Bn(e))return 0;const t=fn(e);return e===0?0:t}function L(i){if(typeof i=="symbol")throw new TypeError("Cannot convert a Symbol value to a String");return Xn(i)}function he(i){const e=ie(i);if(!xe(e))throw new RangeError("infinity is out of range");return e}function En(i,e){const t=ie(i);if(!xe(t))throw new RangeError("infinity is out of range");if(t<1)throw e!==void 0?new RangeError(`property '${e}' cannot be a a number less than one`):new RangeError("Cannot convert a number less than one to a positive integer");return t}function Pe(i){const e=qn(i);if(Bn(e))return 0;if(!xe(e))throw new RangeError("infinity is out of range");if(!Ri(e))throw new RangeError(`unsupported fractional value ${e}`);return ie(e)}function ke(i,e){return{quotient:h.divide(i,e),remainder:h.remainder(i,e)}}function To(i){return h.lessThan(i,_e)?h.multiply(i,Ks):i}const wr=new Map([["year",he],["month",En],["monthCode",L],["day",En],["hour",he],["minute",he],["second",he],["millisecond",he],["microsecond",he],["nanosecond",he],["years",Pe],["months",Pe],["weeks",Pe],["days",Pe],["hours",Pe],["minutes",Pe],["seconds",Pe],["milliseconds",Pe],["microseconds",Pe],["nanoseconds",Pe],["era",L],["eraYear",ie],["offset",L]]),bn=["year","month","week","day","hour","minute","second","millisecond","microsecond","nanosecond"],$r=[["years","year"],["months","month"],["weeks","week"],["days","day"],["hours","hour"],["minutes","minute"],["seconds","second"],["milliseconds","millisecond"],["microseconds","microsecond"],["nanoseconds","nanosecond"]],Qo=new Map;function Oi(i){let e=Qo.get(i);return e===void 0&&(e=new Di("en-us",{timeZone:Xn(i),hour12:!1,era:"short",year:"numeric",month:"numeric",day:"numeric",hour:"numeric",minute:"numeric",second:"numeric"}),Qo.set(i,e)),e}function Re(i){return Ye(i,P)&&!Ye(i,ee,E)}function Ct(i){return Ye(i,Ut)}function be(i){return Ye(i,De)}function pe(i){return Ye(i,Se,$e,ze,Ge,He,We,Ve,Be,Xe)}function X(i){return Ye(i,"slot-date-brand")}function ve(i){return Ye(i,Z,j,A,q,U,S)&&!Ye(i,O,$,I)}function H(i){return Ye(i,O,$,I,Z,j,A,q,U,S)}function ne(i){return Ye(i,"slot-year-month-brand")}function Ne(i){return Ye(i,"slot-month-day-brand")}function Y(i){return Ye(i,P,ee,E)}function $n(i){if(Ye(i,E)||Ye(i,ee))throw new TypeError("with() does not support a calendar or timeZone property");if(i.calendar!==void 0)throw new TypeError("with() does not support a calendar property");if(i.timeZone!==void 0)throw new TypeError("with() does not support a timeZone property")}function $i(i){let{ianaName:e,offset:t,z:n}=function(s){try{let a=Ro(s);if(a)return a=a.toString(),yn(a)?{offset:a}:{ianaName:a}}catch{}try{const a=Pt(s);if(a.z||a.offset||a.ianaName)return a}catch{}throw new RangeError(`Invalid time zone: ${s}`)}(i);return e||(n?"UTC":t)}function Qn(i,e){return e==="never"||e==="auto"&&i==="iso8601"?"":`[u-ca=${i}]`}function Pt(i){const e=qs.exec(i);if(!e)throw new RangeError(`invalid ISO 8601 string: ${i}`);let t=e[1];if(t[0]==="\u2212"&&(t=`-${t.slice(1)}`),t==="-000000")throw new RangeError(`invalid ISO 8601 string: ${i}`);const n=ie(t),r=ie(e[2]||e[4]),s=ie(e[3]||e[5]),a=ie(e[6]),c=e[6]!==void 0,l=ie(e[7]||e[10]);let d=ie(e[8]||e[11]);d===60&&(d=59);const m=(e[9]||e[12])+"000000000",u=ie(m.slice(0,3)),f=ie(m.slice(3,6)),y=ie(m.slice(6,9));let g,w=!1;if(e[13])g=void 0,w=!0;else if(e[14]&&e[15]){const v=e[14]==="-"||e[14]==="\u2212"?"-":"+",T=e[15]||"00",b=e[16]||"00",D=e[17]||"00";let _=e[18]||"0";if(g=`${v}${T}:${b}`,+_){for(;_.endsWith("0");)_=_.slice(0,-1);g+=`:${D}.${_}`}else+D&&(g+=`:${D}`);g==="-00:00"&&(g="+00:00")}let p=e[19];if(p)try{p=Ro(p).toString()}catch{}return{year:n,month:r,day:s,hasTime:c,hour:a,minute:l,second:d,millisecond:u,microsecond:f,nanosecond:y,ianaName:p,offset:g,z:w,calendar:e[20]}}function ki(i){const e=Ss.exec(i);let t,n,r,s;if(e){let a=e[1];if(a[0]==="\u2212"&&(a=`-${a.slice(1)}`),a==="-000000")throw new RangeError(`invalid ISO 8601 string: ${i}`);t=ie(a),n=ie(e[2]),r=e[3]}else{let a;if({year:t,month:n,calendar:r,day:s,z:a}=Pt(i),a)throw new RangeError("Z designator not supported for PlainYearMonth")}return{year:t,month:n,calendar:r,referenceISODay:s}}function Ii(i){const e=zs.exec(i);let t,n,r,s;if(e)t=ie(e[1]),n=ie(e[2]);else{let a;if({month:t,day:n,calendar:r,year:s,z:a}=Pt(i),a)throw new RangeError("Z designator not supported for PlainMonthDay")}return{month:t,day:n,calendar:r,referenceISOYear:s}}function Yi(i){const e=Hs.exec(i);if(!e)throw new RangeError(`invalid duration: ${i}`);if(e.slice(2).every(p=>p===void 0))throw new RangeError(`invalid duration: ${i}`);const t=e[1]==="-"||e[1]==="\u2212"?-1:1,n=ie(e[2])*t,r=ie(e[3])*t,s=ie(e[4])*t,a=ie(e[5])*t,c=ie(e[6])*t;let l=e[7],d=ie(e[8])*t,m=e[9],u=ie(e[10])*t;const f=e[11]+"000000000";let y=ie(f.slice(0,3))*t,g=ie(f.slice(3,6))*t,w=ie(f.slice(6,9))*t;return l=l?t*ie(l)/10**l.length:0,m=m?t*ie(m)/10**m.length:0,{minutes:d,seconds:u,milliseconds:y,microseconds:g,nanoseconds:w}=function(v,T,b,D,_,C,M){let k=v,N=T,J=b,K=D,V=_,F=C,G=M;if(k!==0){[N,J,K,V,F,G].forEach(B=>{if(B!==0)throw new RangeError("only the smallest unit can be fractional")});const R=60*k;N=fn(R),J=R%1}if(J!==0){[K,V,F,G].forEach(se=>{if(se!==0)throw new RangeError("only the smallest unit can be fractional")});const R=60*J;K=fn(R);const B=R%1;if(B!==0){const se=1e3*B;V=fn(se);const re=se%1;if(re!==0){const ae=1e3*re;F=fn(ae);const we=ae%1;we!==0&&(G=fn(1e3*we))}}}return{minutes:N,seconds:K,milliseconds:V,microseconds:F,nanoseconds:G}}(l,d,m,u,y,g,w),{years:n,months:r,weeks:s,days:a,hours:c,minutes:d,seconds:u,milliseconds:y,microseconds:g,nanoseconds:w}}function ea(i){const{year:e,month:t,day:n,hour:r,minute:s,second:a,millisecond:c,microsecond:l,nanosecond:d,offset:m,z:u}=function(w){const p=Pt(w);if(!p.z&&!p.offset)throw new RangeError("Temporal.Instant requires a time zone offset");return p}(i),f=Vt(e,t,n,r,s,a,c,l,d);if(f===null)throw new RangeError("DateTime outside of supported range");const y=u?0:an(m);return h.subtract(f,h.BigInt(y))}function pr(i,e,t,n){let r=i,s=e,a=t;switch(n){case"reject":$t(r,s,a);break;case"constrain":({year:r,month:s,day:a}=Vi(r,s,a))}return{year:r,month:s,day:a}}function Fn(i,e,t,n,r,s,a){let c=i,l=e,d=t,m=n,u=r,f=s;switch(a){case"reject":jr(c,l,d,m,u,f);break;case"constrain":({hour:c,minute:l,second:d,millisecond:m,microsecond:u,nanosecond:f}=function(g,w,p,v,T,b){const D=at(g,0,23),_=at(w,0,59),C=at(p,0,59),M=at(v,0,999),k=at(T,0,999),N=at(b,0,999);return{hour:D,minute:_,second:C,millisecond:M,microsecond:k,nanosecond:N}}(c,l,d,m,u,f))}return{hour:c,minute:l,second:d,millisecond:m,microsecond:u,nanosecond:f}}function Ni(i){if(pe(i))return{years:o(i,Se),months:o(i,$e),weeks:o(i,et),days:o(i,ze),hours:o(i,Ge),minutes:o(i,He),seconds:o(i,We),milliseconds:o(i,Ve),microseconds:o(i,Be),nanoseconds:o(i,Xe)};const e=Bt(i,["days","hours","microseconds","milliseconds","minutes","months","nanoseconds","seconds","weeks","years"]);if(!e)throw new TypeError("invalid duration-like");const{years:t=0,months:n=0,weeks:r=0,days:s=0,hours:a=0,minutes:c=0,seconds:l=0,milliseconds:d=0,microseconds:m=0,nanoseconds:u=0}=e;return{years:t,months:n,weeks:r,days:s,hours:a,minutes:c,seconds:l,milliseconds:d,microseconds:m,nanoseconds:u}}function vt(i,e=[]){let t;ue(i)?t=Ni(i):t=Yi(L(i));const{years:n,months:r,weeks:s,days:a,hours:c,minutes:l,seconds:d,milliseconds:m,microseconds:u,nanoseconds:f}=t;Ki(n,r,s,a,c,l,d,m,u,f);for(const y of e)if(t[y]!==0)throw new RangeError(`Duration field ${y} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`);return t}function Le(i){return kt(i,"overflow",["constrain","reject"],"constrain")}function Un(i){return kt(i,"disambiguation",["compatible","earlier","later","reject"],"compatible")}function Oe(i,e){return kt(i,"roundingMode",["ceil","floor","trunc","halfExpand"],e)}function Kn(i){switch(i){case"ceil":return"floor";case"floor":return"ceil";default:return i}}function no(i,e){return kt(i,"offset",["prefer","use","ignore","reject"],e)}function Jn(i){return kt(i,"calendarName",["auto","always","never"],"auto")}function ft(i,e,t){let n=1/0;e!==void 0&&(n=e),t||e===void 0||(n=e>1?e-1:1);const r=function(a,c,l,d,m){let u=a[c];if(u===void 0)return m;const f=qn(u);if(Bn(f)||f<l||f>d)throw new RangeError(`${c} must be between ${l} and ${d}, not ${f}`);return Ie(f)}(i,"roundingIncrement",1,n,1);if(e!==void 0&&e%r!=0)throw new RangeError(`Rounding increment must divide evenly into ${e}`);return r}function Sn(i,e){return ft(i,{year:void 0,month:void 0,week:void 0,day:void 0,hour:24,minute:60,second:60,millisecond:1e3,microsecond:1e3,nanosecond:1e3}[e],!1)}function er(i){switch(Je(i,void 0,["year","month","week","day","hour"])){case"minute":return{precision:"minute",unit:"minute",increment:1};case"second":return{precision:0,unit:"second",increment:1};case"millisecond":return{precision:3,unit:"millisecond",increment:1};case"microsecond":return{precision:6,unit:"microsecond",increment:1};case"nanosecond":return{precision:9,unit:"nanosecond",increment:1}}let e=i.fractionalSecondDigits;if(e===void 0&&(e="auto"),typeof e!="number"){const n=L(e);if(n==="auto")return{precision:"auto",unit:"nanosecond",increment:1};throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${n}`)}if(Bn(e)||e<0||e>9)throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${e}`);const t=Ie(e);switch(t){case 0:return{precision:t,unit:"second",increment:1};case 1:case 2:case 3:return{precision:t,unit:"millisecond",increment:10**(3-t)};case 4:case 5:case 6:return{precision:t,unit:"microsecond",increment:10**(6-t)};case 7:case 8:case 9:return{precision:t,unit:"nanosecond",increment:10**(9-t)};default:throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${e}`)}}function ut(i,e,t=[],n){const r=new Map($r.filter(([,c])=>!t.includes(c))),s=new Set(bn);for(const c of t)s.delete(c);const a=kt(i,"largestUnit",["auto",...s,...r.keys()],e);return a==="auto"&&n!==void 0?n:r.has(a)?r.get(a):a}function Je(i,e,t=[]){const n=new Map($r.filter(([,a])=>!t.includes(a))),r=new Set(bn);for(const a of t)r.delete(a);const s=kt(i,"smallestUnit",[...r,...n.keys()],e);return n.has(s)?n.get(s):s}function In(i){const e=i.relativeTo;if(e===void 0)return e;let t,n,r,s,a,c,l,d,m,u,f,y,g="option",w=!1;if(ue(e)){if(Y(e)||X(e))return e;if(H(e))return tn(e);u=kn(e);const p=vr(e,Ee(u,["day","hour","microsecond","millisecond","minute","month","monthCode","nanosecond","second","year"])),v=le(null);v.overflow="constrain",{year:t,month:n,day:r,hour:s,minute:a,second:c,millisecond:l,microsecond:d,nanosecond:m}=tr(u,p,v),y=e.offset,y===void 0&&(g="wall"),f=e.timeZone}else{let p,v;({year:t,month:n,day:r,hour:s,minute:a,second:c,millisecond:l,microsecond:d,nanosecond:m,calendar:u,ianaName:p,offset:y,z:v}=Pt(L(e))),p&&(f=p),v?g="exact":y||(g="wall"),u||(u=Ce()),u=Ae(u),w=!0}if(f){f=nt(f);let p=0;return g==="option"&&(p=an(L(y))),Fe(Tr(t,n,r,s,a,c,l,d,m,g,p,f,"compatible","reject",w),f,u)}return Et(t,n,r,u)}function yt(i,e){if(bn.indexOf(i)>bn.indexOf(e))throw new RangeError(`largestUnit ${i} cannot be smaller than smallestUnit ${e}`)}function ro(i,e,t,n,r,s,a,c,l,d){const m=new Map($r);for(const[u,f]of[["years",i],["months",e],["weeks",t],["days",n],["hours",r],["minutes",s],["seconds",a],["milliseconds",c],["microseconds",l],["nanoseconds",d]])if(f!==0)return m.get(u);return"nanosecond"}function Tt(i,e){return bn.indexOf(i)>bn.indexOf(e)?e:i}function Bt(i,e){const t=i,n=e;let r=!1,s={};for(const a of n){const c=t[a];c!==void 0&&(r=!0,wr.has(a)?s[a]=wr.get(a)(c):s[a]=c)}return!!r&&s}function Ze(i,e){const t=i,n=e,r={};let s=!1;for(const a of n){const[c,l]=a;let d=t[c];if(d===void 0){if(a.length===1)throw new TypeError(`required property '${c}' missing or undefined`);d=l}else s=!0,wr.has(c)&&(d=wr.get(c)(d));r[c]=d}if(!s)throw new TypeError("no supported properties found");if(r.era===void 0!=(r.eraYear===void 0))throw new RangeError("properties 'era' and 'eraYear' must be provided together");return r}function oo(i,e){const t=[["day",void 0],["month",void 0],["monthCode",void 0],["year",void 0]];return e.forEach(n=>{t.some(([r])=>r===n)||t.push([n,void 0])}),Ze(i,t)}function vr(i,e){const t=[["day",void 0],["hour",0],["microsecond",0],["millisecond",0],["minute",0],["month",void 0],["monthCode",void 0],["nanosecond",0],["second",0],["year",void 0]];return e.forEach(n=>{t.some(([r])=>r===n)||t.push([n,void 0])}),Ze(i,t)}function en(i,e){const t=[["day",void 0],["month",void 0],["monthCode",void 0],["year",void 0]];return e.forEach(n=>{t.some(([r])=>r===n)||t.push([n,void 0])}),Ze(i,t)}function Eo(i){return Ze(i,[["hour",0],["microsecond",0],["millisecond",0],["minute",0],["nanosecond",0],["second",0]])}function it(i,e){const t=[["month",void 0],["monthCode",void 0],["year",void 0]];return e.forEach(n=>{t.some(([r])=>r===n)||t.push([n,void 0])}),Ze(i,t)}function ce(i,e=le(null)){let t=i;if(ue(t)){if(X(t))return t;if(Y(t)&&(t=mt(o(t,ee),o(t,qe),o(t,E))),H(t))return Et(o(t,O),o(t,$),o(t,I),o(t,E));const l=kn(t);return bt(l,oo(t,Ee(l,["day","month","monthCode","year"])),e)}Le(e);const{year:n,month:r,day:s,calendar:a,z:c}=function(d){return Pt(d)}(L(t));if(c)throw new RangeError("Z designator not supported for PlainDate");return new(x("%Temporal.PlainDate%"))(n,r,s,a)}function tr(i,e,t){let{hour:n,minute:r,second:s,millisecond:a,microsecond:c,nanosecond:l}=Eo(e);const d=Le(t),m=bt(i,e,t),u=o(m,O),f=o(m,$),y=o(m,I);return{hour:n,minute:r,second:s,millisecond:a,microsecond:c,nanosecond:l}=Fn(n,r,s,a,c,l,d),{year:u,month:f,day:y,hour:n,minute:r,second:s,millisecond:a,microsecond:c,nanosecond:l}}function St(i,e=le(null)){let t,n,r,s,a,c,l,d,m,u;if(ue(i)){if(H(i))return i;if(Y(i))return mt(o(i,ee),o(i,qe),o(i,E));if(X(i))return rt(o(i,O),o(i,$),o(i,I),0,0,0,0,0,0,o(i,E));u=kn(i);const f=vr(i,Ee(u,["day","hour","microsecond","millisecond","minute","month","monthCode","nanosecond","second","year"]));({year:t,month:n,day:r,hour:s,minute:a,second:c,millisecond:l,microsecond:d,nanosecond:m}=tr(u,f,e))}else{let f;if(Le(e),{year:t,month:n,day:r,hour:s,minute:a,second:c,millisecond:l,microsecond:d,nanosecond:m,calendar:u,z:f}=function(g){return Pt(g)}(L(i)),f)throw new RangeError("Z designator not supported for PlainDateTime");Xi(t,n,r,s,a,c,l,d,m),u===void 0&&(u=Ce()),u=Ae(u)}return rt(t,n,r,s,a,c,l,d,m,u)}function gn(i){let e,t,n,r,s,a,c,l,d,m;if(ue(i)){if(pe(i))return i;({years:e,months:t,weeks:n,days:r,hours:s,minutes:a,seconds:c,milliseconds:l,microseconds:d,nanoseconds:m}=Ni(i))}else({years:e,months:t,weeks:n,days:r,hours:s,minutes:a,seconds:c,milliseconds:l,microseconds:d,nanoseconds:m}=Yi(L(i)));return new(x("%Temporal.Duration%"))(e,t,n,r,s,a,c,l,d,m)}function Dt(i){if(Re(i))return i;if(Y(i))return new(x("%Temporal.Instant%"))(o(i,P));const e=ea(L(i));return new(x("%Temporal.Instant%"))(e)}function Ko(i,e=le(null)){if(ue(i)){if(Ne(i))return i;let c,l;if(Ye(i,E))c=o(i,E),l=!1;else{let m=i.calendar;l=m===void 0,m===void 0&&(m=Ce()),c=Ae(m)}const d=en(i,Ee(c,["day","month","monthCode","year"]));return l&&d.month!==void 0&&d.monthCode===void 0&&d.year===void 0&&(d.year=1972),Dn(c,d,e)}Le(e);let{month:t,day:n,referenceISOYear:r,calendar:s}=Ii(L(i)),a=s;return a===void 0&&(a=Ce()),a=Ae(a),r===void 0?($t(1972,t,n),zn(t,n,a)):Dn(a,zn(t,n,a,r),le(null))}function Mt(i,e="constrain"){let t,n,r,s,a,c,l,d=i;if(ue(d)){if(ve(d))return d;if(Y(d)&&(d=mt(o(d,ee),o(d,qe),o(d,E))),H(d))return new(x("%Temporal.PlainTime%"))(o(d,Z),o(d,j),o(d,A),o(d,q),o(d,U),o(d,S));if(l=kn(d),L(l)!=="iso8601")throw new RangeError("PlainTime can only have iso8601 calendar");({hour:t,minute:n,second:r,millisecond:s,microsecond:a,nanosecond:c}=Eo(d)),{hour:t,minute:n,second:r,millisecond:s,microsecond:a,nanosecond:c}=Fn(t,n,r,s,a,c,e)}else if({hour:t,minute:n,second:r,millisecond:s,microsecond:a,nanosecond:c,calendar:l}=function(u){const f=Us.exec(u);let y,g,w,p,v,T,b;if(f){y=ie(f[1]),g=ie(f[2]||f[5]),w=ie(f[3]||f[6]),w===60&&(w=59);const D=(f[4]||f[7])+"000000000";p=ie(D.slice(0,3)),v=ie(D.slice(3,6)),T=ie(D.slice(6,9)),b=f[15]}else{let D,_;if({hasTime:_,hour:y,minute:g,second:w,millisecond:p,microsecond:v,nanosecond:T,calendar:b,z:D}=Pt(u),!_)throw new RangeError(`time is missing in string: ${u}`);if(D)throw new RangeError("Z designator not supported for PlainTime")}if(/[tT ][0-9][0-9]/.test(u))return{hour:y,minute:g,second:w,millisecond:p,microsecond:v,nanosecond:T,calendar:b};try{const{month:D,day:_}=Ii(u);$t(1972,D,_)}catch{try{const{year:D,month:_}=ki(u);$t(D,_,1)}catch{return{hour:y,minute:g,second:w,millisecond:p,microsecond:v,nanosecond:T,calendar:b}}}throw new RangeError(`invalid ISO 8601 time-only string ${u}; may need a T prefix`)}(L(d)),jr(t,n,r,s,a,c),l!==void 0&&l!=="iso8601")throw new RangeError("PlainTime can only have iso8601 calendar");return new(x("%Temporal.PlainTime%"))(t,n,r,s,a,c)}function dn(i,e=le(null)){if(ue(i)){if(ne(i))return i;const c=kn(i);return Ht(c,it(i,Ee(c,["month","monthCode","year"])),e)}Le(e);let{year:t,month:n,referenceISODay:r,calendar:s}=ki(L(i)),a=s;return a===void 0&&(a=Ce()),a=Ae(a),r===void 0?($t(t,n,1),Gn(t,n,a)):Ht(a,Gn(t,n,a,r),le(null))}function Tr(i,e,t,n,r,s,a,c,l,d,m,u,f,y,g){const w=new(x("%Temporal.PlainDateTime%"))(i,e,t,n,r,s,a,c,l);if(d==="wall"||y==="ignore")return o(tt(u,w,f),P);if(d==="exact"||y==="use"){const v=Vt(i,e,t,n,r,s,a,c,l);if(v===null)throw new RangeError("ZonedDateTime outside of supported range");return h.subtract(v,h.BigInt(m))}const p=Er(u,w);for(const v of p){const T=_t(u,v),b=h.toNumber(st(h.BigInt(T),6e10,"halfExpand"));if(T===m||g&&b===m)return o(v,P)}if(y==="reject"){const v=Oo(m),T=Ct(u)?o(u,Ut):"time zone";throw new RangeError(`Offset ${v} is invalid for ${w.toString()} in ${T}`)}return o(Ai(p,u,w,f),P)}function un(i,e=le(null)){let t,n,r,s,a,c,l,d,m,u,f,y,g=!1,w="option";if(ue(i)){if(Y(i))return i;y=kn(i);const v=function(b,D){const _=[["day",void 0],["hour",0],["microsecond",0],["millisecond",0],["minute",0],["month",void 0],["monthCode",void 0],["nanosecond",0],["second",0],["year",void 0],["offset",void 0],["timeZone"]];return D.forEach(C=>{_.some(([M])=>M===C)||_.push([C,void 0])}),Ze(b,_)}(i,Ee(y,["day","hour","microsecond","millisecond","minute","month","monthCode","nanosecond","second","year"]));({year:t,month:n,day:r,hour:s,minute:a,second:c,millisecond:l,microsecond:d,nanosecond:m}=tr(y,v,e)),u=nt(v.timeZone),f=v.offset,f===void 0?w="wall":f=L(f)}else{let v,T;if(Le(e),{year:t,month:n,day:r,hour:s,minute:a,second:c,millisecond:l,microsecond:d,nanosecond:m,ianaName:v,offset:f,z:T,calendar:y}=function(D){const _=Pt(D);if(!_.ianaName)throw new RangeError("Temporal.ZonedDateTime requires a time zone ID in brackets");return _}(L(i)),!v)throw new RangeError("time zone ID required in brackets");T?w="exact":f||(w="wall"),u=new(x("%Temporal.TimeZone%"))(v),y||(y=Ce()),y=Ae(y),g=!0}let p=0;return w==="option"&&(p=an(f)),Fe(Tr(t,n,r,s,a,c,l,d,m,w,p,u,Un(e),no(e,"reject"),g),u,y)}function Pi(i,e,t,n,r){$t(e,t,n),Bi(e,t,n),Nt(i),W(i,O,e),W(i,$,t),W(i,I,n),W(i,E,r),W(i,"slot-date-brand",!0)}function Et(i,e,t,n=Ce()){const r=x("%Temporal.PlainDate%"),s=le(r.prototype);return Pi(s,i,e,t,n),s}function Fi(i,e,t,n,r,s,a,c,l,d,m){Xi(e,t,n,r,s,a,c,l,d),Qi(e,t,n,r,s,a,c,l,d),Nt(i),W(i,O,e),W(i,$,t),W(i,I,n),W(i,Z,r),W(i,j,s),W(i,A,a),W(i,q,c),W(i,U,l),W(i,S,d),W(i,E,m)}function rt(i,e,t,n,r,s,a,c,l,d=Ce()){const m=x("%Temporal.PlainDateTime%"),u=le(m.prototype);return Fi(u,i,e,t,n,r,s,a,c,l,d),u}function xi(i,e,t,n,r){$t(r,e,t),Bi(r,e,t),Nt(i),W(i,$,e),W(i,I,t),W(i,O,r),W(i,E,n),W(i,"slot-month-day-brand",!0)}function zn(i,e,t=Ce(),n=1972){const r=x("%Temporal.PlainMonthDay%"),s=le(r.prototype);return xi(s,i,e,t,n),s}function Li(i,e,t,n,r){$t(e,t,r),function(a,c){Ue(a,-271821,275760),a===-271821?Ue(c,4,12):a===275760&&Ue(c,1,9)}(e,t),Nt(i),W(i,O,e),W(i,$,t),W(i,I,r),W(i,E,n),W(i,"slot-year-month-brand",!0)}function Gn(i,e,t=Ce(),n=1){const r=x("%Temporal.PlainYearMonth%"),s=le(r.prototype);return Li(s,i,e,t,n),s}function Zi(i,e,t,n){Kt(e),Nt(i),W(i,P,e),W(i,ee,t),W(i,E,n);const r=new(x("%Temporal.Instant%"))(o(i,P));W(i,qe,r)}function Fe(i,e,t=Ce()){const n=x("%Temporal.ZonedDateTime%"),r=le(n.prototype);return Zi(r,i,e,t),r}function Ce(){return new(x("%Temporal.Calendar%"))("iso8601")}function Ee(i,e){let t=e;i.fields&&(t=i.fields(t));const n=[];for(const r of t){if(typeof r!="string")throw new TypeError("bad return from calendar.fields()");bi.call(n,r)}return n}function sn(i,e,t){const n=i.mergeFields;if(!n)return Q(Q({},e),t);const r=Reflect.apply(n,i,[e,t]);if(!ue(r))throw new TypeError("bad return from calendar.mergeFields()");return r}function Ke(i,e,t,n,r){let s=r;s===void 0&&(s=i.dateAdd);const a=po(s,i,[e,t,n]);if(!X(a))throw new TypeError("invalid result");return a}function Ot(i,e,t,n,r){let s=r;s===void 0&&(s=i.dateUntil);const a=po(s,i,[e,t,n]);if(!pe(a))throw new TypeError("invalid result");return a}function kr(i,e){const t=i.year(e);if(t===void 0)throw new RangeError("calendar year result must be an integer");return he(t)}function Ir(i,e){const t=i.month(e);if(t===void 0)throw new RangeError("calendar month result must be a positive integer");return En(t)}function nr(i,e){const t=i.monthCode(e);if(t===void 0)throw new RangeError("calendar monthCode result must be a string");return L(t)}function Yr(i,e){const t=i.day(e);if(t===void 0)throw new RangeError("calendar day result must be a positive integer");return En(t)}function Nr(i,e){let t=i.era(e);return t!==void 0&&(t=L(t)),t}function Pr(i,e){let t=i.eraYear(e);return t!==void 0&&(t=he(t)),t}function bo(i,e){return i.dayOfWeek(e)}function Do(i,e){return i.dayOfYear(e)}function _o(i,e){return i.weekOfYear(e)}function Co(i,e){return i.daysInWeek(e)}function wn(i,e){return i.daysInMonth(e)}function Fr(i,e){return i.daysInYear(e)}function xr(i,e){return i.monthsInYear(e)}function Lr(i,e){return i.inLeapYear(e)}function Ae(i){let e=i;if(ue(e)){if(Ye(e,E))return o(e,E);if(!("calendar"in e)||(e=e.calendar,ue(e)&&!("calendar"in e)))return e}const t=L(e),n=x("%Temporal.Calendar%");if(gi(t))return new n(t);let r;try{({calendar:r}=Pt(t))}catch{throw new RangeError(`Invalid calendar: ${t}`)}return r||(r="iso8601"),new n(r)}function kn(i){if(Ye(i,E))return o(i,E);const{calendar:e}=i;return e===void 0?Ce():Ae(e)}function rr(i,e){return i===e?!0:L(i)===L(e)}function ji(i,e){if(i===e)return e;const t=L(i),n=L(e);if(t===n||t==="iso8601")return e;if(n==="iso8601")return i;throw new RangeError("irreconcilable calendars")}function bt(i,e,t){const n=i.dateFromFields(e,t);if(!X(n))throw new TypeError("invalid result");return n}function Ht(i,e,t){const n=i.yearMonthFromFields(e,t);if(!ne(n))throw new TypeError("invalid result");return n}function Dn(i,e,t){const n=i.monthDayFromFields(e,t);if(!Ne(n))throw new TypeError("invalid result");return n}function nt(i){let e=i;if(ue(e)){if(Y(e))return o(e,ee);if(!("timeZone"in e)||(e=e.timeZone,ue(e)&&!("timeZone"in e)))return e}const t=$i(L(e));return new(x("%Temporal.TimeZone%"))(t)}function Hr(i,e){return i===e?!0:L(i)===L(e)}function tn(i){return Et(o(i,O),o(i,$),o(i,I),o(i,E))}function Mo(i){return new(x("%Temporal.PlainTime%"))(o(i,Z),o(i,j),o(i,A),o(i,q),o(i,U),o(i,S))}function _t(i,e){let t=i.getOffsetNanosecondsFor;if(typeof t!="function")throw new TypeError("getOffsetNanosecondsFor not callable");const n=Reflect.apply(t,i,[e]);if(typeof n!="number")throw new TypeError("bad return from getOffsetNanosecondsFor");if(!Ri(n)||te(n)>864e11)throw new RangeError("out-of-range return from getOffsetNanosecondsFor");return n}function io(i,e){return Oo(_t(i,e))}function mt(i,e,t){const n=o(e,P),r=_t(i,e);let{year:s,month:a,day:c,hour:l,minute:d,second:m,millisecond:u,microsecond:f,nanosecond:y}=Ui(n);return{year:s,month:a,day:c,hour:l,minute:d,second:m,millisecond:u,microsecond:f,nanosecond:y}=Hi(s,a,c,l,d,m,u,f,y+r),rt(s,a,c,l,d,m,u,f,y,t)}function tt(i,e,t){return Ai(Er(i,e),i,e,t)}function Ai(i,e,t,n){const r=x("%Temporal.Instant%"),s=i.length;if(s===1)return i[0];if(s)switch(n){case"compatible":case"earlier":return i[0];case"later":return i[s-1];case"reject":throw new RangeError("multiple instants found")}const a=o(t,O),c=o(t,$),l=o(t,I),d=o(t,Z),m=o(t,j),u=o(t,A),f=o(t,q),y=o(t,U),g=o(t,S),w=Vt(a,c,l,d,m,u,f,y,g);if(w===null)throw new RangeError("DateTime outside of supported range");const p=new r(h.subtract(w,Wt)),v=new r(h.add(w,Wt)),T=_t(e,p),b=_t(e,v)-T;switch(n){case"earlier":{const D=o(t,E),_=x("%Temporal.PlainDateTime%"),C=Cr(a,c,l,d,m,u,f,y,g,D,0,0,0,0,0,0,0,0,0,-b,void 0);return Er(e,new _(C.year,C.month,C.day,C.hour,C.minute,C.second,C.millisecond,C.microsecond,C.nanosecond,D))[0]}case"compatible":case"later":{const D=o(t,E),_=x("%Temporal.PlainDateTime%"),C=Cr(a,c,l,d,m,u,f,y,g,D,0,0,0,0,0,0,0,0,0,b,void 0),M=Er(e,new _(C.year,C.month,C.day,C.hour,C.minute,C.second,C.millisecond,C.microsecond,C.nanosecond,D));return M[M.length-1]}case"reject":throw new RangeError("no such instant found")}}function Er(i,e){const t=i.getPossibleInstantsFor(e),n=[];for(const r of t){if(!Re(r))throw new TypeError("bad return from getPossibleInstantsFor");bi.call(n,r)}return n}function hn(i){let e;return i<1e3||i>9999?e=(i<0?"-":"+")+`000000${te(i)}`.slice(-6):e=`${i}`,e}function fe(i){return`00${i}`.slice(-2)}function Zr(i,e,t,n,r){if(r==="minute")return"";const s=`:${fe(i)}`;let a,c=1e6*e+1e3*t+n;if(r==="auto"){if(c===0)return s;for(a=`${c}`.padStart(9,"0");a[a.length-1]==="0";)a=a.slice(0,-1)}else{if(r===0)return s;a=`${c}`.padStart(9,"0").slice(0,r)}return`${s}.${a}`}function Jo(i,e,t){let n=e;n===void 0&&(n=new(x("%Temporal.TimeZone%"))("UTC"));const r=mt(n,i,Ce()),s=hn(o(r,O)),a=fe(o(r,$)),c=fe(o(r,I)),l=fe(o(r,Z)),d=fe(o(r,j)),m=Zr(o(r,A),o(r,q),o(r,U),o(r,S),t);let u="Z";return e!==void 0&&(u=qi(_t(n,i))),`${s}-${a}-${c}T${l}:${d}${m}${u}`}function Wr(i,e="auto",t){function n(N){return N<=Xs?N.toString(10):h.BigInt(N).toString(10)}const r=o(i,Se),s=o(i,$e),a=o(i,et),c=o(i,ze),l=o(i,Ge),d=o(i,He);let m=o(i,We),u=o(i,Ve),f=o(i,Be),y=o(i,Xe);const g=pt(r,s,a,c,l,d,m,u,f,y);if(t){const{unit:N,increment:J,roundingMode:K}=t;({seconds:m,milliseconds:u,microseconds:f,nanoseconds:y}=gt(0,0,0,0,0,0,m,u,f,y,J,N,K))}const w=[];r&&w.push(`${n(te(r))}Y`),s&&w.push(`${n(te(s))}M`),a&&w.push(`${n(te(a))}W`),c&&w.push(`${n(te(c))}D`);const p=[];l&&p.push(`${n(te(l))}H`),d&&p.push(`${n(te(d))}M`);const v=[];let T,b,D,_,C=_n(0,0,0,m,u,f,y,0);({quotient:C,remainder:T}=ke(C,oe)),{quotient:C,remainder:b}=ke(C,oe),{quotient:_,remainder:D}=ke(C,oe);const M=1e6*te(h.toNumber(D))+1e3*te(h.toNumber(b))+te(h.toNumber(T));let k;if(e==="auto"){if(M!==0)for(k=`${M}`.padStart(9,"0");k[k.length-1]==="0";)k=k.slice(0,-1)}else e!==0&&(k=`${M}`.padStart(9,"0").slice(0,e));return k&&v.unshift(".",k),h.equal(_,_e)&&!v.length&&e==="auto"||v.unshift(To(_).toString()),v.length&&p.push(`${v.join("")}S`),p.length&&p.unshift("T"),w.length||p.length?`${g<0?"-":""}P${w.join("")}${p.join("")}`:"PT0S"}function ei(i,e="auto"){return`${hn(o(i,O))}-${fe(o(i,$))}-${fe(o(i,I))}${Qn(L(o(i,E)),e)}`}function ti(i,e,t="auto",n){let r=o(i,O),s=o(i,$),a=o(i,I),c=o(i,Z),l=o(i,j),d=o(i,A),m=o(i,q),u=o(i,U),f=o(i,S);if(n){const{unit:y,increment:g,roundingMode:w}=n;({year:r,month:s,day:a,hour:c,minute:l,second:d,millisecond:m,microsecond:u,nanosecond:f}=Io(r,s,a,c,l,d,m,u,f,g,y,w))}return`${hn(r)}-${fe(s)}-${fe(a)}T${fe(c)}:${fe(l)}${Zr(d,m,u,f,e)}${Qn(L(o(i,E)),t)}`}function ni(i,e="auto"){let t=`${fe(o(i,$))}-${fe(o(i,I))}`;const n=L(o(i,E));n!=="iso8601"&&(t=`${hn(o(i,O))}-${t}`);const r=Qn(n,e);return r&&(t+=r),t}function ri(i,e="auto"){let t=`${hn(o(i,O))}-${fe(o(i,$))}`;const n=L(o(i,E));n!=="iso8601"&&(t+=`-${fe(o(i,I))}`);const r=Qn(n,e);return r&&(t+=r),t}function oi(i,e,t="auto",n="auto",r="auto",s){let a=o(i,qe);if(s){const{unit:m,increment:u,roundingMode:f}=s,y=Mr(o(i,P),u,m,f);a=new(x("%Temporal.Instant%"))(y)}const c=o(i,ee),l=mt(c,a,Ce());let d=`${hn(o(l,O))}-${fe(o(l,$))}-${fe(o(l,I))}T${fe(o(l,Z))}:${fe(o(l,j))}${Zr(o(l,A),o(l,q),o(l,U),o(l,S),e)}`;return r!=="never"&&(d+=qi(_t(c,a))),n!=="never"&&(d+=`[${c}]`),d+=Qn(L(o(i,E)),t),d}function yn(i){return Ji.test(Xn(i))}function an(i){const e=Ji.exec(Xn(i));if(!e)throw new RangeError(`invalid time zone offset: ${i}`);return(e[1]==="-"||e[1]==="\u2212"?-1:1)*(1e9*(60*(60*+e[2]+ +(e[3]||0))+ +(e[4]||0))+ +((e[5]||0)+"000000000").slice(0,9))}function Ro(i){return yn(i)?Oo(an(i)):Oi(Xn(i)).resolvedOptions().timeZone}function Ft(i,e){const{year:t,month:n,day:r,hour:s,minute:a,second:c,millisecond:l,microsecond:d,nanosecond:m}=Si(i,e),u=Vt(t,n,r,s,a,c,l,d,m);if(u===null)throw new RangeError("Date outside of supported range");return h.toNumber(h.subtract(u,i))}function Oo(i){const e=i<0?"-":"+",t=te(i),n=t%1e9,r=Ie(t/1e9)%60,s=Ie(t/6e10)%60,a=fe(Ie(t/36e11)),c=fe(s),l=fe(r);let d="";if(n){let m=`${n}`.padStart(9,"0");for(;m[m.length-1]==="0";)m=m.slice(0,-1);d=`:${l}.${m}`}else r&&(d=`:${l}`);return`${e}${a}:${c}${d}`}function qi(i){let e=h.toNumber(st(h.BigInt(i),6e10,"halfExpand"));const t=e<0?"-":"+";e=te(e);const n=e/6e10%60;return`${t}${fe(Ie(e/36e11))}:${fe(n)}`}function Vt(i,e,t,n,r,s,a,c,l){const d=new Date;d.setUTCHours(n,r,s,a),d.setUTCFullYear(i,e-1,t);const m=d.getTime();if(Bn(m))return null;let u=h.multiply(h.BigInt(m),lt);return u=h.add(u,h.multiply(h.BigInt(c),oe)),u=h.add(u,h.BigInt(l)),h.lessThan(u,jn)||h.greaterThan(u,An)?null:u}function Ui(i){const{quotient:e,remainder:t}=ke(i,lt);let n=h.toNumber(e),r=h.toNumber(t);r<0&&(r+=1e6,n-=1);const s=Ie(r/1e3)%1e3,a=r%1e3,c=new Date(n);return{epochMilliseconds:n,year:c.getUTCFullYear(),month:c.getUTCMonth()+1,day:c.getUTCDate(),hour:c.getUTCHours(),minute:c.getUTCMinutes(),second:c.getUTCSeconds(),millisecond:c.getUTCMilliseconds(),microsecond:s,nanosecond:a}}function Si(i,e){const{epochMilliseconds:t,millisecond:n,microsecond:r,nanosecond:s}=Ui(i),{year:a,month:c,day:l,hour:d,minute:m,second:u}=function(y,g){const w=Oi(y);return function(v){const T=v.split(/[^\w]+/);if(T.length!==7)throw new RangeError(`expected 7 parts in "${v}`);const b=+T[0],D=+T[1];let _=+T[2];const C=T[3].toUpperCase();if(C==="B"||C==="BC")_=1-_;else if(C!=="A"&&C!=="AD")throw new RangeError(`Unknown era ${C} in "${v}`);let M=+T[4];M===24&&(M=0);const k=+T[5],N=+T[6];if(!(xe(_)&&xe(b)&&xe(D)&&xe(M)&&xe(k)&&xe(N)))throw new RangeError(`Invalid number in "${v}`);return{year:_,month:b,day:D,hour:M,minute:k,second:N}}(w.format(new Date(g)))}(e,t);return Hi(a,c,l,d,m,u,n,r,s)}function ii(i,e){return h.lessThan(i,e)?e:i}function zi(){return h.add(No(),Js)}function Gi(i,e){const t=zi(),n=h.greaterThan(i,t),r=n?h.subtract(i,Ci):_i;let s=h.subtract(i,vo);const a=Ft(s,e);let c=s,l=a;for(;a===l&&h.greaterThan(s,r);)c=h.subtract(s,Mi),l=Ft(c,e),a===l&&(s=c);return a===l?n?Gi(h.subtract(t,Wt),e):null:es(d=>Ft(d,e),c,s,l,a)}function Gt(i){return i===void 0?!1:i%4==0&&(i%100!=0||i%400==0)}function qt(i,e){return{standard:[31,28,31,30,31,30,31,31,30,31,30,31],leapyear:[31,29,31,30,31,30,31,31,30,31,30,31]}[Gt(i)?"leapyear":"standard"][e-1]}function Vr(i,e,t){const n=e+(e<3?10:-2),r=i-(e<3?1:0),s=Ie(r/100),a=r-100*s,c=(t+Ie(2.6*n-.2)+(a+Ie(a/4))+(Ie(s/4)-2*s))%7;return c+(c<=0?7:0)}function br(i,e,t){let n=t;for(let r=e-1;r>0;r--)n+=qt(i,r);return n}function pt(i,e,t,n,r,s,a,c,l,d){for(const m of[i,e,t,n,r,s,a,c,l,d])if(m!==0)return m<0?-1:1;return 0}function ur(i,e){let t=i,n=e;if(!xe(t)||!xe(n))throw new RangeError("infinity is out of range");return n-=1,t+=Ie(n/12),n%=12,n<0&&(n+=12),n+=1,{year:t,month:n}}function Hn(i,e,t){let n=i,r=e,s=t;if(!xe(s))throw new RangeError("infinity is out of range");({year:n,month:r}=ur(n,r));let a=0,c=r>2?n:n-1;for(;a=Gt(c)?366:365,s<-a;)n-=1,c-=1,s+=a;for(c+=1;a=Gt(c)?366:365,s>a;)n+=1,c+=1,s-=a;for(;s<1;)({year:n,month:r}=ur(n,r-1)),s+=qt(n,r);for(;s>qt(n,r);)s-=qt(n,r),{year:n,month:r}=ur(n,r+1);return{year:n,month:r,day:s}}function Hi(i,e,t,n,r,s,a,c,l){const{deltaDays:d,hour:m,minute:u,second:f,millisecond:y,microsecond:g,nanosecond:w}=xt(n,r,s,a,c,l),{year:p,month:v,day:T}=Hn(i,e,t+d);return{year:p,month:v,day:T,hour:m,minute:u,second:f,millisecond:y,microsecond:g,nanosecond:w}}function xt(i,e,t,n,r,s){let a=i,c=e,l=t,d=n,m=r,u=s;if(!(xe(a)&&xe(c)&&xe(l)&&xe(d)&&xe(m)&&xe(u)))throw new RangeError("infinity is out of range");m+=Ie(u/1e3),u=mn(u,1e3),d+=Ie(m/1e3),m=mn(m,1e3),l+=Ie(d/1e3),d=mn(d,1e3),c+=Ie(l/60),l=mn(l,60),a+=Ie(c/60),c=mn(c,60);const f=Ie(a/24);return a=mn(a,24),{deltaDays:f,hour:a,minute:c,second:l,millisecond:d,microsecond:m,nanosecond:u}}function _n(i,e,t,n,r,s,a,c){const l=h.BigInt(i);let d=h.BigInt(a);i!==0&&(d=h.subtract(h.BigInt(a),h.BigInt(c)));const m=h.add(h.BigInt(e),h.multiply(l,h.BigInt(24))),u=h.add(h.BigInt(t),h.multiply(m,Jt)),f=h.add(h.BigInt(n),h.multiply(u,Jt)),y=h.add(h.BigInt(r),h.multiply(f,oe)),g=h.add(h.BigInt(s),h.multiply(y,oe));return h.add(h.BigInt(d),h.multiply(g,oe))}function $o(i,e){const t=x("%Temporal.Instant%"),n=Zn(h.toNumber(i));let r=h.BigInt(i),s=864e11;if(n===0)return{days:0,nanoseconds:_e,dayLengthNs:s};if(!Y(e)){let T;return{quotient:T,remainder:r}=ke(r,h.BigInt(s)),{days:h.toNumber(T),nanoseconds:r,dayLengthNs:s}}const a=o(e,P),c=o(e,qe),l=h.add(a,r),d=new t(l),m=o(e,ee),u=o(e,E),f=mt(m,c,u),y=mt(m,d,u);let{days:g}=Dr(o(f,O),o(f,$),o(f,I),o(f,Z),o(f,j),o(f,A),o(f,q),o(f,U),o(f,S),o(y,O),o(y,$),o(y,I),o(y,Z),o(y,j),o(y,A),o(y,q),o(y,U),o(y,S),u,"day"),w=dt(c,m,u,0,0,0,g,0,0,0,0,0,0);if(n===1)for(;g>0&&h.greaterThan(w,l);)--g,w=dt(c,m,u,0,0,0,g,0,0,0,0,0,0);r=h.subtract(l,w);let p=!1,v=new t(w);do{const T=dt(v,m,u,0,0,0,n,0,0,0,0,0,0),b=o(v,P);s=h.toNumber(h.subtract(T,b)),p=h.greaterThan(h.multiply(h.subtract(r,h.BigInt(s)),h.BigInt(n)),_e),p&&(r=h.subtract(r,h.BigInt(s)),v=new t(T),g+=n)}while(p);return{days:g,nanoseconds:r,dayLengthNs:te(s)}}function je(i,e,t,n,r,s,a,c,l){let d,m,u,f,y,g,w=i;if(Y(l)){const v=dt(o(l,qe),o(l,ee),o(l,E),0,0,0,w,e,t,n,r,s,a),T=o(l,P);d=h.subtract(v,T)}else d=_n(w,e,t,n,r,s,a,0);c==="year"||c==="month"||c==="week"||c==="day"?{days:w,nanoseconds:d}=$o(d,l):w=0;const p=h.lessThan(d,_e)?-1:1;switch(d=To(d),m=u=f=y=g=_e,c){case"year":case"month":case"week":case"day":case"hour":({quotient:m,remainder:d}=ke(d,oe)),{quotient:u,remainder:m}=ke(m,oe),{quotient:f,remainder:u}=ke(u,oe),{quotient:y,remainder:f}=ke(f,Jt),{quotient:g,remainder:y}=ke(y,Jt);break;case"minute":({quotient:m,remainder:d}=ke(d,oe)),{quotient:u,remainder:m}=ke(m,oe),{quotient:f,remainder:u}=ke(u,oe),{quotient:y,remainder:f}=ke(f,Jt);break;case"second":({quotient:m,remainder:d}=ke(d,oe)),{quotient:u,remainder:m}=ke(m,oe),{quotient:f,remainder:u}=ke(u,oe);break;case"millisecond":({quotient:m,remainder:d}=ke(d,oe)),{quotient:u,remainder:m}=ke(m,oe);break;case"microsecond":({quotient:m,remainder:d}=ke(d,oe));break;case"nanosecond":break;default:throw new Error("assert not reached")}return{days:w,hours:h.toNumber(g)*p,minutes:h.toNumber(y)*p,seconds:h.toNumber(f)*p,milliseconds:h.toNumber(u)*p,microseconds:h.toNumber(m)*p,nanoseconds:h.toNumber(d)*p}}function cr(i,e,t,n,r,s){let a=i,c=e,l=t,d=n;const m=x("%Temporal.Duration%"),u=pt(a,c,l,d,0,0,0,0,0,0);let f,y;s&&(y=ce(s),f=o(y,E));const g=new m(u),w=new m(0,u),p=new m(0,0,u);switch(r){case"year":break;case"month":{if(!f)throw new RangeError("a starting point is required for months balancing");const v=f.dateAdd,T=f.dateUntil;let b=y;for(;te(a)>0;){const D=Ke(f,b,g,le(null),v),_=le(null);_.largestUnit="month";const C=o(Ot(f,b,D,_,T),$e);b=D,c+=C,a-=u}}break;case"week":if(!f)throw new RangeError("a starting point is required for weeks balancing");for(;te(a)>0;){let v;({relativeTo:y,days:v}=Qe(f,y,g)),d+=v,a-=u}for(;te(c)>0;){let v;({relativeTo:y,days:v}=Qe(f,y,w)),d+=v,c-=u}break;default:for(;te(a)>0;){if(!f)throw new RangeError("a starting point is required for balancing calendar units");let v;({relativeTo:y,days:v}=Qe(f,y,g)),d+=v,a-=u}for(;te(c)>0;){if(!f)throw new RangeError("a starting point is required for balancing calendar units");let v;({relativeTo:y,days:v}=Qe(f,y,w)),d+=v,c-=u}for(;te(l)>0;){if(!f)throw new RangeError("a starting point is required for balancing calendar units");let v;({relativeTo:y,days:v}=Qe(f,y,p)),d+=v,l-=u}}return{years:a,months:c,weeks:l,days:d}}function si(i,e,t,n,r,s,a,c,l,d,m){if(Y(i)){const u=o(i,qe),f=o(i,ee),y=o(i,E),g=_t(f,u),w=dt(u,f,y,e,t,n,r,s,a,c,l,d,m);return _t(f,new(x("%Temporal.Instant%"))(w))-g}return 0}function Wi(i){return new(x("%Temporal.Duration%"))(-o(i,Se),-o(i,$e),-o(i,et),-o(i,ze),-o(i,Ge),-o(i,He),-o(i,We),-o(i,Ve),-o(i,Be),-o(i,Xe))}function at(i,e,t){return Ws(t,Vs(e,i))}function Vi(i,e,t){const n=at(e,1,12);return{year:i,month:n,day:at(t,1,qt(i,n))}}function Ue(i,e,t){if(i<e||i>t)throw new RangeError(`value out of range: ${e} <= ${i} <= ${t}`)}function $t(i,e,t){Ue(e,1,12),Ue(t,1,qt(i,e))}function Bi(i,e,t){Qi(i,e,t,12,0,0,0,0,0)}function jr(i,e,t,n,r,s){Ue(i,0,23),Ue(e,0,59),Ue(t,0,59),Ue(n,0,999),Ue(r,0,999),Ue(s,0,999)}function Xi(i,e,t,n,r,s,a,c,l){$t(i,e,t),jr(n,r,s,a,c,l)}function Qi(i,e,t,n,r,s,a,c,l){if(Ue(i,-271821,275760),i===-271821&&Vt(i,e,t+1,n,r,s,a,c,l-1)==null||i===275760&&Vt(i,e,t-1,n,r,s,a,c,l+1)==null)throw new RangeError("DateTime outside of supported range")}function Kt(i){if(h.lessThan(i,jn)||h.greaterThan(i,An))throw new RangeError("Instant outside of supported range")}function Ki(i,e,t,n,r,s,a,c,l,d){const m=pt(i,e,t,n,r,s,a,c,l,d);for(const u of[i,e,t,n,r,s,a,c,l,d]){if(!xe(u))throw new RangeError("infinite values not allowed as duration fields");const f=Zn(u);if(f!==0&&f!==m)throw new RangeError("mixed-sign values not allowed as duration fields")}}function ko(i,e,t,n,r,s,a){switch(a){case"year":case"month":{const c=-Lt(i,e,t,n,r,s);if(c===0)return{years:0,months:0,weeks:0,days:0};const l={year:i,month:e,day:t},d={year:n,month:r,day:s};let m=d.year-l.year,u=nn(i,e,t,m,0,0,0,"constrain"),f=-Lt(u.year,u.month,u.day,n,r,s);if(f===0)return a==="year"?{years:m,months:0,weeks:0,days:0}:{years:0,months:12*m,weeks:0,days:0};let y=d.month-l.month;if(f!==c&&(m-=c,y+=12*c),u=nn(i,e,t,m,y,0,0,"constrain"),f=-Lt(u.year,u.month,u.day,n,r,s),f===0)return a==="year"?{years:m,months:y,weeks:0,days:0}:{years:0,months:y+12*m,weeks:0,days:0};f!==c&&(y-=c,y===-c&&(m-=c,y=11*c),u=nn(i,e,t,m,y,0,0,"constrain"),f=-Lt(i,e,t,u.year,u.month,u.day));let g=0;return g=u.month===d.month?d.day-u.day:c<0?-u.day-(qt(d.year,d.month)-d.day):d.day+(qt(u.year,u.month)-u.day),a==="month"&&(y+=12*m,m=0),{years:m,months:y,weeks:0,days:g}}case"week":case"day":{let c,l,d;Lt(i,e,t,n,r,s)<0?(l={year:i,month:e,day:t},c={year:n,month:r,day:s},d=1):(l={year:n,month:r,day:s},c={year:i,month:e,day:t},d=-1);let m=br(c.year,c.month,c.day)-br(l.year,l.month,l.day);for(let f=l.year;f<c.year;++f)m+=Gt(f)?366:365;let u=0;return a==="week"&&(u=Ie(m/7),m%=7),u*=d,m*=d,{years:0,months:0,weeks:u,days:m}}default:throw new Error("assert not reached")}}function so(i,e,t,n,r,s,a,c,l,d,m,u){let f=a-i,y=c-e,g=l-t,w=d-n,p=m-r,v=u-s;const T=pt(0,0,0,0,f,y,g,w,p,v);f*=T,y*=T,g*=T,w*=T,p*=T,v*=T;let b=0;return{deltaDays:b,hour:f,minute:y,second:g,millisecond:w,microsecond:p,nanosecond:v}=xt(f,y,g,w,p,v),b*=T,f*=T,y*=T,g*=T,w*=T,p*=T,v*=T,{deltaDays:b,hours:f,minutes:y,seconds:g,milliseconds:w,microseconds:p,nanoseconds:v}}function Wn(i,e,t,n,r){const s=h.subtract(e,i),a=h.remainder(s,h.BigInt(864e11)),c=h.subtract(s,a),l=st(a,Po[n]*t,r),d=h.add(c,l),m=h.toNumber(h.remainder(d,oe)),u=h.toNumber(h.remainder(h.divide(d,oe),oe)),f=h.toNumber(h.remainder(h.divide(d,lt),oe));return{seconds:h.toNumber(h.divide(d,At)),milliseconds:f,microseconds:u,nanoseconds:m}}function Dr(i,e,t,n,r,s,a,c,l,d,m,u,f,y,g,w,p,v,T,b,D=le(null)){let _=i,C=e,M=t,{deltaDays:k,hours:N,minutes:J,seconds:K,milliseconds:V,microseconds:F,nanoseconds:G}=so(n,r,s,a,c,l,f,y,g,w,p,v);const R=pt(0,0,0,k,N,J,K,V,F,G);({year:_,month:C,day:M}=Hn(_,C,M+k)),Lt(d,m,u,_,C,M)===-R&&({year:_,month:C,day:M}=Hn(_,C,M-R),{hours:N,minutes:J,seconds:K,milliseconds:V,microseconds:F,nanoseconds:G}=je(-R,N,J,K,V,F,G,b));const B=Et(_,C,M,T),se=Et(d,m,u,T),re=de(Q({},D),{largestUnit:Tt("day",b)});let{years:ae,months:we,weeks:ot,days:wt}=Ot(T,B,se,re);return{days:wt,hours:N,minutes:J,seconds:K,milliseconds:V,microseconds:F,nanoseconds:G}=je(wt,N,J,K,V,F,G,b),{years:ae,months:we,weeks:ot,days:wt,hours:N,minutes:J,seconds:K,milliseconds:V,microseconds:F,nanoseconds:G}}function ao(i,e,t,n,r,s){const a=h.subtract(e,i);if(h.equal(a,_e))return{years:0,months:0,weeks:0,days:0,hours:0,minutes:0,seconds:0,milliseconds:0,microseconds:0,nanoseconds:0};const c=x("%Temporal.Instant%"),l=new c(i),d=new c(e),m=mt(t,l,n),u=mt(t,d,n);let{years:f,months:y,weeks:g,days:w}=Dr(o(m,O),o(m,$),o(m,I),o(m,Z),o(m,j),o(m,A),o(m,q),o(m,U),o(m,S),o(u,O),o(u,$),o(u,I),o(u,Z),o(u,j),o(u,A),o(u,q),o(u,U),o(u,S),n,r,s);const p=dt(l,t,n,f,y,g,0,0,0,0,0,0,0);let v=h.subtract(e,p);const T=Fe(p,t,n);({nanoseconds:v,days:w}=$o(v,T));const{hours:b,minutes:D,seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=je(0,0,0,0,0,0,h.toNumber(v),"hour");return{years:f,months:y,weeks:g,days:w,hours:b,minutes:D,seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}}function nn(i,e,t,n,r,s,a,c){let l=i,d=e,m=t,u=s,f=a;return l+=n,d+=r,{year:l,month:d}=ur(l,d),{year:l,month:d,day:m}=pr(l,d,m,c),f+=7*u,m+=f,{year:l,month:d,day:m}=Hn(l,d,m),{year:l,month:d,day:m}}function co(i,e,t,n,r,s,a,c,l,d,m,u){let f=i,y=e,g=t,w=n,p=r,v=s;f+=a,y+=c,g+=l,w+=d,p+=m,v+=u;let T=0;return{deltaDays:T,hour:f,minute:y,second:g,millisecond:w,microsecond:p,nanosecond:v}=xt(f,y,g,w,p,v),{deltaDays:T,hour:f,minute:y,second:g,millisecond:w,microsecond:p,nanosecond:v}}function ho(i,e,t,n,r,s,a,c,l,d,m,u,f,y,g,w,p,v,T,b,D){const _=Tt(ro(i,e,t,n,r,s,a,c,l,d),ro(m,u,f,y,g,w,p,v,T,b));let C,M,k,N,J,K,V,F,G,R;if(D)if(X(D)){const B=x("%Temporal.Duration%"),se=o(D,E),re=new B(i,e,t,n,0,0,0,0,0,0),ae=new B(m,u,f,y,0,0,0,0,0,0),we=se.dateAdd,ot=Ke(se,D,re,le(null),we),wt=Ke(se,ot,ae,le(null),we),Te=Tt("day",_),Me=le(null);Me.largestUnit=Te,{years:C,months:M,weeks:k,days:N}=Ot(se,D,wt,Me),{days:N,hours:J,minutes:K,seconds:V,milliseconds:F,microseconds:G,nanoseconds:R}=je(N,r+g,s+w,a+p,c+v,l+T,d+b,_)}else{const B=x("%Temporal.Instant%"),se=o(D,ee),re=o(D,E),ae=dt(o(D,qe),se,re,i,e,t,n,r,s,a,c,l,d),we=dt(new B(ae),se,re,m,u,f,y,g,w,p,v,T,b);_!=="year"&&_!=="month"&&_!=="week"&&_!=="day"?(C=0,M=0,k=0,N=0,{seconds:V,milliseconds:F,microseconds:G,nanoseconds:R}=Wn(o(D,P),we,1,"nanosecond","halfExpand"),{hours:J,minutes:K,seconds:V,milliseconds:F,microseconds:G,nanoseconds:R}=je(0,0,0,V,F,G,R,_)):{years:C,months:M,weeks:k,days:N,hours:J,minutes:K,seconds:V,milliseconds:F,microseconds:G,nanoseconds:R}=ao(o(D,P),we,se,re,_)}else{if(_==="year"||_==="month"||_==="week")throw new RangeError("relativeTo is required for years, months, or weeks arithmetic");C=M=k=0,{days:N,hours:J,minutes:K,seconds:V,milliseconds:F,microseconds:G,nanoseconds:R}=je(n+y,r+g,s+w,a+p,c+v,l+T,d+b,_)}return Ki(C,M,k,N,J,K,V,F,G,R),{years:C,months:M,weeks:k,days:N,hours:J,minutes:K,seconds:V,milliseconds:F,microseconds:G,nanoseconds:R}}function _r(i,e,t,n,r,s,a){let c=_e;c=h.add(c,h.BigInt(a)),c=h.add(c,h.multiply(h.BigInt(s),oe)),c=h.add(c,h.multiply(h.BigInt(r),lt)),c=h.add(c,h.multiply(h.BigInt(n),At)),c=h.add(c,h.multiply(h.BigInt(t),h.BigInt(6e10))),c=h.add(c,h.multiply(h.BigInt(e),h.BigInt(36e11)));const l=h.add(i,c);return Kt(l),l}function Cr(i,e,t,n,r,s,a,c,l,d,m,u,f,y,g,w,p,v,T,b,D){let _=y,{deltaDays:C,hour:M,minute:k,second:N,millisecond:J,microsecond:K,nanosecond:V}=co(n,r,s,a,c,l,g,w,p,v,T,b);_+=C;const F=x("%Temporal.Duration%"),G=Ke(d,Et(i,e,t,d),new F(m,u,f,_,0,0,0,0,0,0),D);return{year:o(G,O),month:o(G,$),day:o(G,I),hour:M,minute:k,second:N,millisecond:J,microsecond:K,nanosecond:V}}function dt(i,e,t,n,r,s,a,c,l,d,m,u,f,y){const g=x("%Temporal.Duration%");if(pt(n,r,s,a,0,0,0,0,0,0)===0)return _r(o(i,P),c,l,d,m,u,f);const w=mt(e,i,t),p=Ke(t,Et(o(w,O),o(w,$),o(w,I),t),new g(n,r,s,a,0,0,0,0,0,0),y),v=rt(o(p,O),o(p,$),o(p,I),o(w,Z),o(w,j),o(w,A),o(w,q),o(w,U),o(w,S),t);return _r(o(tt(e,v,"compatible"),P),c,l,d,m,u,f)}function st(i,e,t){if(e===1)return i;let{quotient:n,remainder:r}=ke(i,h.BigInt(e));if(h.equal(r,_e))return i;const s=h.lessThan(r,_e)?-1:1;switch(t){case"ceil":s>0&&(n=h.add(n,h.BigInt(s)));break;case"floor":s<0&&(n=h.add(n,h.BigInt(s)));break;case"trunc":break;case"halfExpand":h.toNumber(To(h.multiply(r,h.BigInt(2))))>=e&&(n=h.add(n,h.BigInt(s)))}return h.multiply(n,h.BigInt(e))}function Mr(i,e,t,n){let r=h.remainder(i,h.BigInt(864e11));h.lessThan(r,_e)&&(r=h.add(r,h.BigInt(864e11)));const s=h.subtract(i,r),a=st(r,Po[t]*e,n);return h.add(s,a)}function Io(i,e,t,n,r,s,a,c,l,d,m,u,f=864e11){const{deltaDays:y,hour:g,minute:w,second:p,millisecond:v,microsecond:T,nanosecond:b}=Yo(n,r,s,a,c,l,d,m,u,f),{year:D,month:_,day:C}=Hn(i,e,t+y);return{year:D,month:_,day:C,hour:g,minute:w,second:p,millisecond:v,microsecond:T,nanosecond:b}}function Yo(i,e,t,n,r,s,a,c,l,d=864e11){let m=_e;switch(c){case"day":case"hour":m=h.BigInt(i);case"minute":m=h.add(h.multiply(m,Jt),h.BigInt(e));case"second":m=h.add(h.multiply(m,Jt),h.BigInt(t));case"millisecond":m=h.add(h.multiply(m,oe),h.BigInt(n));case"microsecond":m=h.add(h.multiply(m,oe),h.BigInt(r));case"nanosecond":m=h.add(h.multiply(m,oe),h.BigInt(s))}const u=c==="day"?d:Po[c],f=st(m,u*a,l),y=h.toNumber(h.divide(f,h.BigInt(u)));switch(c){case"day":return{deltaDays:y,hour:0,minute:0,second:0,millisecond:0,microsecond:0,nanosecond:0};case"hour":return xt(y,0,0,0,0,0);case"minute":return xt(i,y,0,0,0,0);case"second":return xt(i,e,y,0,0,0);case"millisecond":return xt(i,e,t,y,0,0);case"microsecond":return xt(i,e,t,n,y,0);case"nanosecond":return xt(i,e,t,n,r,y);default:throw new Error(`Invalid unit ${c}`)}}function mr(i,e){return ko(o(i,O),o(i,$),o(i,I),o(e,O),o(e,$),o(e,I),"day").days}function Qe(i,e,t){const n=Ke(i,e,t,le(null));return{relativeTo:n,days:mr(e,n)}}function lo(i,e,t,n,r){const s=o(i,ee),a=o(i,E);return Fe(dt(o(i,qe),s,a,e,t,n,r,0,0,0,0,0,0),s,a)}function uo(i,e,t,n,r,s,a,c,l,d,m,u,f,y){let g=i,w=e,p=t,v=n,T=r,b=s,D=a,_=c,C=l,M=d;if(!Y(y)||u==="year"||u==="month"||u==="week"||u==="day"||u==="nanosecond"&&m===1)return{years:g,months:w,weeks:p,days:v,hours:T,minutes:b,seconds:D,milliseconds:_,microseconds:C,nanoseconds:M};let k=_n(0,T,b,D,_,C,M,0);const N=Zn(h.toNumber(k)),J=o(y,ee),K=o(y,E),V=dt(o(y,qe),J,K,g,w,p,v,0,0,0,0,0,0),F=dt(new(x("%Temporal.Instant%"))(V),J,K,0,0,0,N,0,0,0,0,0,0),G=h.subtract(F,V);return h.greaterThanOrEqual(h.multiply(h.subtract(k,G),h.BigInt(N)),_e)&&({years:g,months:w,weeks:p,days:v}=ho(g,w,p,v,0,0,0,0,0,0,0,0,0,N,0,0,0,0,0,0,y),k=Mr(h.subtract(k,G),m,u,f),{hours:T,minutes:b,seconds:D,milliseconds:_,microseconds:C,nanoseconds:M}=je(0,0,0,0,0,0,h.toNumber(k),"hour")),{years:g,months:w,weeks:p,days:v,hours:T,minutes:b,seconds:D,milliseconds:_,microseconds:C,nanoseconds:M}}function gt(i,e,t,n,r,s,a,c,l,d,m,u,f,y){let g=i,w=e,p=t,v=n,T=r,b=s,D=a,_=c,C=l,M=h.BigInt(d);const k=x("%Temporal.Duration%");let N,J,K,V,F=y;if(F){if(Y(F))J=F,F=ce(F);else if(!X(F))throw new TypeError("starting point must be PlainDate or ZonedDateTime");N=o(F,E)}if(u==="year"||u==="month"||u==="week"||u==="day"){let G,R,B;M=_n(0,T,b,D,_,C,d,0),J&&(G=lo(J,g,w,p,v)),{days:R,nanoseconds:M,dayLengthNs:B}=$o(M,G),K=h.BigInt(B),v+=R,T=b=D=_=C=0}switch(u){case"year":{if(!N)throw new RangeError("A starting point is required for years rounding");const G=new k(g),R=N.dateAdd,B=Ke(N,F,G,le(null),R),se=Ke(N,F,new k(g,w,p),le(null),R);F=B,v+=mr(B,se);const re=Ke(N,F,{days:v},le(null),R),ae=le(null);ae.largestUnit="year";const we=Ot(N,F,re,ae).years;g+=we;const ot=F;F=Ke(N,F,{years:we},le(null),R),v-=mr(ot,F);const wt=new k(v<0?-1:1);let{days:Te}=Qe(N,F,wt);Te=te(Te);const Me=h.multiply(h.BigInt(Te),K);M=h.add(h.add(h.multiply(Me,h.BigInt(g)),h.multiply(h.BigInt(v),K)),M);const ln=st(M,h.toNumber(h.multiply(Me,h.BigInt(m))),f);V=h.toNumber(M)/h.toNumber(Me),g=h.toNumber(h.divide(ln,Me)),M=_e,w=p=v=0;break}case"month":{if(!N)throw new RangeError("A starting point is required for months rounding");const G=new k(g,w),R=N.dateAdd,B=Ke(N,F,G,le(null),R),se=Ke(N,F,new k(g,w,p),le(null),R);F=B,v+=mr(B,se);const re=Zn(v),ae=new k(0,v<0?-1:1);let we;for({relativeTo:F,days:we}=Qe(N,F,ae);te(v)>=te(we);)w+=re,v-=we,{relativeTo:F,days:we}=Qe(N,F,ae);we=te(we);const ot=h.multiply(h.BigInt(we),K);M=h.add(h.add(h.multiply(ot,h.BigInt(w)),h.multiply(h.BigInt(v),K)),M);const wt=st(M,h.toNumber(h.multiply(ot,h.BigInt(m))),f);V=h.toNumber(M)/h.toNumber(ot),w=h.toNumber(h.divide(wt,ot)),M=_e,p=v=0;break}case"week":{if(!N)throw new RangeError("A starting point is required for weeks rounding");const G=Zn(v),R=new k(0,0,v<0?-1:1);let B;for({relativeTo:F,days:B}=Qe(N,F,R);te(v)>=te(B);)p+=G,v-=B,{relativeTo:F,days:B}=Qe(N,F,R);B=te(B);const se=h.multiply(h.BigInt(B),K);M=h.add(h.add(h.multiply(se,h.BigInt(p)),h.multiply(h.BigInt(v),K)),M);const re=st(M,h.toNumber(h.multiply(se,h.BigInt(m))),f);V=h.toNumber(M)/h.toNumber(se),p=h.toNumber(h.divide(re,se)),M=_e,v=0;break}case"day":{const G=K;M=h.add(h.multiply(G,h.BigInt(v)),M);const R=st(M,h.toNumber(h.multiply(G,h.BigInt(m))),f);V=h.toNumber(M)/h.toNumber(G),v=h.toNumber(h.divide(R,G)),M=_e;break}case"hour":{let R=h.multiply(h.BigInt(T),h.BigInt(36e11));R=h.add(R,h.multiply(h.BigInt(b),h.BigInt(6e10))),R=h.add(R,h.multiply(h.BigInt(D),At)),R=h.add(R,h.multiply(h.BigInt(_),lt)),R=h.add(R,h.multiply(h.BigInt(C),oe)),R=h.add(R,M),V=h.toNumber(R)/36e11;const B=st(R,36e11*m,f);T=h.toNumber(h.divide(B,h.BigInt(36e11))),M=_e,b=D=_=C=0;break}case"minute":{let R=h.multiply(h.BigInt(b),h.BigInt(6e10));R=h.add(R,h.multiply(h.BigInt(D),At)),R=h.add(R,h.multiply(h.BigInt(_),lt)),R=h.add(R,h.multiply(h.BigInt(C),oe)),R=h.add(R,M),V=h.toNumber(R)/6e10;const B=st(R,6e10*m,f);b=h.toNumber(h.divide(B,h.BigInt(6e10))),M=_e,D=_=C=0;break}case"second":{let R=h.multiply(h.BigInt(D),At);R=h.add(R,h.multiply(h.BigInt(_),lt)),R=h.add(R,h.multiply(h.BigInt(C),oe)),R=h.add(R,M),V=h.toNumber(R)/1e9;const B=st(R,1e9*m,f);D=h.toNumber(h.divide(B,h.BigInt(1e9))),M=_e,_=C=0;break}case"millisecond":{let R=h.multiply(h.BigInt(_),lt);R=h.add(R,h.multiply(h.BigInt(C),oe)),R=h.add(R,M),V=h.toNumber(R)/1e6;const B=st(R,1e6*m,f);_=h.toNumber(h.divide(B,h.BigInt(1e6))),M=_e,C=0;break}case"microsecond":{let R=h.multiply(h.BigInt(C),oe);R=h.add(R,M),V=h.toNumber(R)/1e3;const B=st(R,1e3*m,f);C=h.toNumber(h.divide(B,h.BigInt(1e3))),M=_e;break}case"nanosecond":V=h.toNumber(M),M=st(M,m,f)}return{years:g,months:w,weeks:p,days:v,hours:T,minutes:b,seconds:D,milliseconds:_,microseconds:C,nanoseconds:h.toNumber(M),total:V}}function Lt(i,e,t,n,r,s){for(const[a,c]of[[i,n],[e,r],[t,s]])if(a!==c)return rn(a-c);return 0}function mn(i,e){let t=i%e;return Qs(t,-0)?0:(t<0&&(t+=e),t)}function Rr(i){const e=pn(i);return globalThis.BigInt!==void 0?globalThis.BigInt(e.toString(10)):e}function pn(i){if(i instanceof h)return i;let e=i;if(typeof i=="object"){const t=i[Symbol.toPrimitive];t&&typeof t=="function"&&(e=po(t,i,["number"]))}switch(typeof e){case"undefined":case"object":case"number":case"symbol":default:throw new TypeError(`cannot convert ${typeof i} to bigint`);case"string":if(!e.match(/^\s*(?:[+-]?\d+\s*)?$/))throw new SyntaxError("invalid BigInt syntax");case"bigint":try{return h.BigInt(e.toString())}catch(t){throw t instanceof Error&&t.message.startsWith("Invalid integer")?new SyntaxError(t.message):t}case"boolean":return e?vo:_e}}const No=(()=>{let i=h.BigInt(Date.now()%1e6);return()=>{const e=h.BigInt(Date.now()),t=h.add(h.multiply(e,lt),i);return i=h.divide(e,lt),h.greaterThan(t,An)?An:h.lessThan(t,jn)?jn:t}})();function rn(i){return i<0?-1:i>0?1:i}function z(i){if(i===void 0)return le(null);if(ue(i)&&i!==null)return i;throw new TypeError("Options parameter must be an object, not "+(i===null?"null":typeof i))}function Cn(i,e){const t=le(null);return t[i]=e,t}function kt(i,e,t,n){let r=i[e];if(r!==void 0){if(r=L(r),!t.includes(r))throw new RangeError(`${e} must be one of ${t.join(", ")}, not ${r}`);return r}return n}const Ji=new RegExp(`^${vi.source}$`);function es(i,e,t,n=i(e),r=i(t)){let s=h.BigInt(e),a=h.BigInt(t),c=n,l=r;for(;h.greaterThan(h.subtract(a,s),vo);){const d=h.divide(h.add(s,a),h.BigInt(2)),m=i(d);if(m===c)s=d,c=m;else{if(m!==l)throw new Error(`invalid state in bisection ${c} - ${m} - ${l}`);a=d,l=m}}return a}const Po={hour:36e11,minute:6e10,second:1e9,millisecond:1e6,microsecond:1e3,nanosecond:1},ts=Symbol("date"),ns=Symbol("ym"),rs=Symbol("md"),os=Symbol("time"),is=Symbol("datetime"),ss=Symbol("zoneddatetime"),as=Symbol("instant"),vn=Symbol("original"),mo=Symbol("timezone"),fr=Symbol("timezone-id-given"),ct=Symbol("calendar-id"),cs=Symbol("locale"),fo=Symbol("options"),xn=i=>({value:i,enumerable:!0,writable:!1,configurable:!0}),on=globalThis.Intl.DateTimeFormat,It=Object.assign,ta=Object.prototype.hasOwnProperty,na=Reflect.apply;function Qt(i,e){let t=i[e];return typeof t=="function"&&(t=new on(i[cs],t(i[fo])),i[e]=t),t}function Yn(i){let e=i[mo];return typeof e=="string"&&(e=nt(e),i[mo]=e),e}function cn(i,e={}){if(!(this instanceof cn))return new cn(i,e);const t=e!==void 0,n=t?It({},e):{},r=new on(i,n),s=r.resolvedOptions();if(t){const a=It({},s);for(const c in a)na(ta,n,[c])||delete a[c];this[fo]=a}else this[fo]=n;this[fr]=n.timeZone?n.timeZone:null,this[cs]=s.locale,this[vn]=r,this[mo]=s.timeZone,this[ct]=s.calendar,this[ts]=sa,this[ns]=oa,this[rs]=ia,this[os]=ra,this[is]=aa,this[ss]=ca,this[as]=ha}Object.defineProperty(cn,"name",{writable:!0,value:"DateTimeFormat"}),cn.supportedLocalesOf=function(i,e){return on.supportedLocalesOf(i,e)};const Br={resolvedOptions:xn(function(){return this[vn].resolvedOptions()}),format:xn(function(e,...t){let{instant:n,formatter:r,timeZone:s}=Tn(e,this);return n&&r?(r=Or(r,s),r.format(n.epochMilliseconds)):this[vn].format(e,...t)}),formatRange:xn(function(e,t){if(Mn(e)||Mn(t)){if(!hs(e,t))throw new TypeError("Intl.DateTimeFormat.formatRange accepts two values of the same type");const{instant:n,formatter:r,timeZone:s}=Tn(e,this),{instant:a,formatter:c,timeZone:l}=Tn(t,this);if(s&&l&&s!==l)throw new RangeError("cannot format range between different time zones");if(n&&a&&r&&c&&r===c)return Or(r,s).formatRange(n.epochMilliseconds,a.epochMilliseconds)}return this[vn].formatRange(e,t)})};"formatToParts"in on.prototype&&(Br.formatToParts=xn(function(e,...t){let{instant:n,formatter:r,timeZone:s}=Tn(e,this);return n&&r?(r=Or(r,s),r.formatToParts(n.epochMilliseconds)):this[vn].formatToParts(e,...t)})),"formatRangeToParts"in on.prototype&&(Br.formatRangeToParts=xn(function(e,t){if(Mn(e)||Mn(t)){if(!hs(e,t))throw new TypeError("Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type");const{instant:n,formatter:r,timeZone:s}=Tn(e,this),{instant:a,formatter:c,timeZone:l}=Tn(t,this);if(s&&l&&s!==l)throw new RangeError("cannot format range between different time zones");if(n&&a&&r&&c&&r===c)return Or(r,s).formatRangeToParts(n.epochMilliseconds,a.epochMilliseconds)}return this[vn].formatRangeToParts(e,t)})),cn.prototype=Object.create(on.prototype,Br),Object.defineProperty(cn,"prototype",{writable:!1,enumerable:!1,configurable:!1});const Xt=cn;function Or(i,e){if(!e)return i;const t=i.resolvedOptions();return t.timeZone===e?i:((t.dateStyle||t.timeStyle)&&(delete t.weekday,delete t.era,delete t.year,delete t.month,delete t.day,delete t.hour,delete t.minute,delete t.second,delete t.timeZoneName,delete t.hourCycle,delete t.hour12,delete t.dayPeriod),new on(t.locale,de(Q({},t),{timeZone:e})))}function or(i={},e={}){const t=It({},i);for(const n of["year","month","day","hour","minute","second","weekday","dayPeriod","timeZoneName","dateStyle","timeStyle"])t[n]=n in e?e[n]:t[n],t[n]!==!1&&t[n]!==void 0||delete t[n];return t}function ra(i){let e=or(i,{year:!1,month:!1,day:!1,weekday:!1,timeZoneName:!1,dateStyle:!1});return qr(e)||(e=It({},e,{hour:"numeric",minute:"numeric",second:"numeric"})),e}function oa(i){let e=or(i,{day:!1,hour:!1,minute:!1,second:!1,weekday:!1,dayPeriod:!1,timeZoneName:!1,dateStyle:!1,timeStyle:!1});return"year"in e||"month"in e||(e=It(e,{year:"numeric",month:"numeric"})),e}function ia(i){let e=or(i,{year:!1,hour:!1,minute:!1,second:!1,weekday:!1,dayPeriod:!1,timeZoneName:!1,dateStyle:!1,timeStyle:!1});return"month"in e||"day"in e||(e=It({},e,{month:"numeric",day:"numeric"})),e}function sa(i){let e=or(i,{hour:!1,minute:!1,second:!1,dayPeriod:!1,timeZoneName:!1,timeStyle:!1});return Ar(e)||(e=It({},e,{year:"numeric",month:"numeric",day:"numeric"})),e}function aa(i){let e=or(i,{timeZoneName:!1});return qr(e)||Ar(e)||(e=It({},e,{year:"numeric",month:"numeric",day:"numeric",hour:"numeric",minute:"numeric",second:"numeric"})),e}function ca(i){let e=i;return qr(e)||Ar(e)||(e=It({},e,{year:"numeric",month:"numeric",day:"numeric",hour:"numeric",minute:"numeric",second:"numeric"}),e.timeZoneName===void 0&&(e.timeZoneName="short")),e}function ha(i){let e=i;return qr(e)||Ar(e)||(e=It({},e,{year:"numeric",month:"numeric",day:"numeric",hour:"numeric",minute:"numeric",second:"numeric"})),e}function Ar(i){return"year"in i||"month"in i||"day"in i||"weekday"in i||"dateStyle"in i}function qr(i){return"hour"in i||"minute"in i||"second"in i||"timeStyle"in i||"dayPeriod"in i}function Mn(i){return X(i)||ve(i)||H(i)||Y(i)||ne(i)||Ne(i)||Re(i)}function hs(i,e){return!(!Mn(i)||!Mn(e))&&!(ve(i)&&!ve(e))&&!(X(i)&&!X(e))&&!(H(i)&&!H(e))&&!(Y(i)&&!Y(e))&&!(ne(i)&&!ne(e))&&!(Ne(i)&&!Ne(e))&&!(Re(i)&&!Re(e))}function Tn(i,e){const t=x("%Temporal.PlainDateTime%");if(ve(i)){const n=new t(1970,1,1,o(i,Z),o(i,j),o(i,A),o(i,q),o(i,U),o(i,S),e[ct]);return{instant:tt(Yn(e),n,"compatible"),formatter:Qt(e,os)}}if(ne(i)){const n=o(i,O),r=o(i,$),s=o(i,I),a=L(o(i,E));if(a!==e[ct])throw new RangeError(`cannot format PlainYearMonth with calendar ${a} in locale with calendar ${e[ct]}`);const c=new t(n,r,s,12,0,0,0,0,0,a);return{instant:tt(Yn(e),c,"compatible"),formatter:Qt(e,ns)}}if(Ne(i)){const n=o(i,O),r=o(i,$),s=o(i,I),a=L(o(i,E));if(a!==e[ct])throw new RangeError(`cannot format PlainMonthDay with calendar ${a} in locale with calendar ${e[ct]}`);const c=new t(n,r,s,12,0,0,0,0,0,a);return{instant:tt(Yn(e),c,"compatible"),formatter:Qt(e,rs)}}if(X(i)){const n=o(i,O),r=o(i,$),s=o(i,I),a=L(o(i,E));if(a!=="iso8601"&&a!==e[ct])throw new RangeError(`cannot format PlainDate with calendar ${a} in locale with calendar ${e[ct]}`);const c=new t(n,r,s,12,0,0,0,0,0,e[ct]);return{instant:tt(Yn(e),c,"compatible"),formatter:Qt(e,ts)}}if(H(i)){const n=o(i,O),r=o(i,$),s=o(i,I),a=o(i,Z),c=o(i,j),l=o(i,A),d=o(i,q),m=o(i,U),u=o(i,S),f=L(o(i,E));if(f!=="iso8601"&&f!==e[ct])throw new RangeError(`cannot format PlainDateTime with calendar ${f} in locale with calendar ${e[ct]}`);let y=i;return f==="iso8601"&&(y=new t(n,r,s,a,c,l,d,m,u,e[ct])),{instant:tt(Yn(e),y,"compatible"),formatter:Qt(e,is)}}if(Y(i)){const n=L(o(i,E));if(n!=="iso8601"&&n!==e[ct])throw new RangeError(`cannot format ZonedDateTime with calendar ${n} in locale with calendar ${e[ct]}`);const r=L(o(i,ee));if(e[fr]&&e[fr]!==r)throw new RangeError(`timeZone option ${e[fr]} doesn't match actual time zone ${r}`);return{instant:o(i,qe),formatter:Qt(e,ss),timeZone:r}}return Re(i)?{instant:i,formatter:Qt(e,as)}:{}}Object.freeze({__proto__:null,DateTimeFormat:Xt});const Nn=["year","month","week","day"],ai={hour:24,minute:60,second:60,millisecond:1e3,microsecond:1e3,nanosecond:1e3};class ht{constructor(e){if(arguments.length<1)throw new TypeError("missing argument: epochNanoseconds is required");const t=pn(e);Kt(t),Nt(this),W(this,P,t)}get epochSeconds(){if(!Re(this))throw new TypeError("invalid receiver");const e=o(this,P);return h.toNumber(h.divide(e,At))}get epochMilliseconds(){if(!Re(this))throw new TypeError("invalid receiver");const e=h.BigInt(o(this,P));return h.toNumber(h.divide(e,lt))}get epochMicroseconds(){if(!Re(this))throw new TypeError("invalid receiver");const e=h.BigInt(o(this,P));return Rr(h.divide(e,oe))}get epochNanoseconds(){if(!Re(this))throw new TypeError("invalid receiver");return Rr(h.BigInt(o(this,P)))}add(e){if(!Re(this))throw new TypeError("invalid receiver");const{hours:t,minutes:n,seconds:r,milliseconds:s,microseconds:a,nanoseconds:c}=vt(e,["years","months","weeks","days"]),l=_r(o(this,P),t,n,r,s,a,c);return new ht(l)}subtract(e){if(!Re(this))throw new TypeError("invalid receiver");const{hours:t,minutes:n,seconds:r,milliseconds:s,microseconds:a,nanoseconds:c}=vt(e,["years","months","weeks","days"]),l=_r(o(this,P),-t,-n,-r,-s,-a,-c);return new ht(l)}until(e,t){if(!Re(this))throw new TypeError("invalid receiver");const n=Dt(e),r=z(t),s=Je(r,"nanosecond",Nn),a=Tt("second",s),c=ut(r,"auto",Nn,a);yt(c,s);const l=Oe(r,"trunc"),d=ft(r,ai[s],!1),m=o(this,P),u=o(n,P);let f,y,{seconds:g,milliseconds:w,microseconds:p,nanoseconds:v}=Wn(m,u,d,s,l);return{hours:f,minutes:y,seconds:g,milliseconds:w,microseconds:p,nanoseconds:v}=je(0,0,0,g,w,p,v,c),new(x("%Temporal.Duration%"))(0,0,0,0,f,y,g,w,p,v)}since(e,t){if(!Re(this))throw new TypeError("invalid receiver");const n=Dt(e),r=z(t),s=Je(r,"nanosecond",Nn),a=Tt("second",s),c=ut(r,"auto",Nn,a);yt(c,s);const l=Oe(r,"trunc"),d=ft(r,ai[s],!1),m=o(n,P),u=o(this,P);let f,y,{seconds:g,milliseconds:w,microseconds:p,nanoseconds:v}=Wn(m,u,d,s,l);return{hours:f,minutes:y,seconds:g,milliseconds:w,microseconds:p,nanoseconds:v}=je(0,0,0,g,w,p,v,c),new(x("%Temporal.Duration%"))(0,0,0,0,f,y,g,w,p,v)}round(e){if(!Re(this))throw new TypeError("invalid receiver");if(e===void 0)throw new TypeError("options parameter is required");const t=typeof e=="string"?Cn("smallestUnit",e):z(e),n=Je(t,void 0,Nn);if(n===void 0)throw new RangeError("smallestUnit is required");const r=Oe(t,"halfExpand"),s=ft(t,{hour:24,minute:1440,second:86400,millisecond:864e5,microsecond:864e8,nanosecond:864e11}[n],!0),a=Mr(o(this,P),s,n,r);return new ht(a)}equals(e){if(!Re(this))throw new TypeError("invalid receiver");const t=Dt(e),n=o(this,P),r=o(t,P);return h.equal(h.BigInt(n),h.BigInt(r))}toString(e){if(!Re(this))throw new TypeError("invalid receiver");const t=z(e);let n=t.timeZone;n!==void 0&&(n=nt(n));const{precision:r,unit:s,increment:a}=er(t),c=Oe(t,"trunc"),l=Mr(o(this,P),a,s,c);return Jo(new ht(l),n,r)}toJSON(){if(!Re(this))throw new TypeError("invalid receiver");return Jo(this,void 0,"auto")}toLocaleString(e,t){if(!Re(this))throw new TypeError("invalid receiver");return new Xt(e,t).format(this)}valueOf(){throw new TypeError("use compare() or equals() to compare Temporal.Instant")}toZonedDateTime(e){if(!Re(this))throw new TypeError("invalid receiver");if(!ue(e))throw new TypeError("invalid argument in toZonedDateTime");const t=e.calendar;if(t===void 0)throw new TypeError("missing calendar property in toZonedDateTime");const n=Ae(t),r=e.timeZone;if(r===void 0)throw new TypeError("missing timeZone property in toZonedDateTime");const s=nt(r);return Fe(o(this,P),s,n)}toZonedDateTimeISO(e){let t=e;if(!Re(this))throw new TypeError("invalid receiver");if(ue(t)){const s=t.timeZone;s!==void 0&&(t=s)}const n=nt(t),r=Ce();return Fe(o(this,P),n,r)}static fromEpochSeconds(e){const t=qn(e),n=h.multiply(h.BigInt(t),At);return Kt(n),new ht(n)}static fromEpochMilliseconds(e){const t=qn(e),n=h.multiply(h.BigInt(t),lt);return Kt(n),new ht(n)}static fromEpochMicroseconds(e){const t=pn(e),n=h.multiply(t,oe);return Kt(n),new ht(n)}static fromEpochNanoseconds(e){const t=pn(e);return Kt(t),new ht(t)}static from(e){return Re(e)?new ht(o(e,P)):Dt(e)}static compare(e,t){const n=Dt(e),r=Dt(t),s=o(n,P),a=o(r,P);return h.lessThan(s,a)?-1:h.greaterThan(s,a)?1:0}}Yt(ht,"Temporal.Instant");const hr=["hour","minute","second","millisecond","microsecond","nanosecond"];class ir{constructor(e,t,n,r=Ce()){const s=he(e),a=he(t),c=he(n),l=Ae(r);if(arguments.length<3)throw new RangeError("missing argument: isoYear, isoMonth and isoDay are required");Pi(this,s,a,c,l)}get calendar(){if(!X(this))throw new TypeError("invalid receiver");return o(this,E)}get era(){if(!X(this))throw new TypeError("invalid receiver");return Nr(o(this,E),this)}get eraYear(){if(!X(this))throw new TypeError("invalid receiver");return Pr(o(this,E),this)}get year(){if(!X(this))throw new TypeError("invalid receiver");return kr(o(this,E),this)}get month(){if(!X(this))throw new TypeError("invalid receiver");return Ir(o(this,E),this)}get monthCode(){if(!X(this))throw new TypeError("invalid receiver");return nr(o(this,E),this)}get day(){if(!X(this))throw new TypeError("invalid receiver");return Yr(o(this,E),this)}get dayOfWeek(){if(!X(this))throw new TypeError("invalid receiver");return bo(o(this,E),this)}get dayOfYear(){if(!X(this))throw new TypeError("invalid receiver");return Do(o(this,E),this)}get weekOfYear(){if(!X(this))throw new TypeError("invalid receiver");return _o(o(this,E),this)}get daysInWeek(){if(!X(this))throw new TypeError("invalid receiver");return Co(o(this,E),this)}get daysInMonth(){if(!X(this))throw new TypeError("invalid receiver");return wn(o(this,E),this)}get daysInYear(){if(!X(this))throw new TypeError("invalid receiver");return Fr(o(this,E),this)}get monthsInYear(){if(!X(this))throw new TypeError("invalid receiver");return xr(o(this,E),this)}get inLeapYear(){if(!X(this))throw new TypeError("invalid receiver");return Lr(o(this,E),this)}with(e,t){if(!X(this))throw new TypeError("invalid receiver");if(!ue(e))throw new TypeError("invalid argument");$n(e);const n=o(this,E),r=Ee(n,["day","month","monthCode","year"]),s=Bt(e,r);if(!s)throw new TypeError("invalid date-like");let a=oo(this,r);return a=sn(n,a,s),a=oo(a,r),bt(n,a,z(t))}withCalendar(e){if(!X(this))throw new TypeError("invalid receiver");const t=Ae(e);return new ir(o(this,O),o(this,$),o(this,I),t)}add(e,t){if(!X(this))throw new TypeError("invalid receiver");const n=gn(e),r=z(t);return Ke(o(this,E),this,n,r)}subtract(e,t){if(!X(this))throw new TypeError("invalid receiver");const n=Wi(gn(e)),r=z(t);return Ke(o(this,E),this,n,r)}until(e,t){if(!X(this))throw new TypeError("invalid receiver");const n=ce(e),r=o(this,E),s=o(n,E),a=L(r),c=L(s);if(a!==c)throw new RangeError(`cannot compute difference between dates of ${a} and ${c} calendars`);const l=z(t),d=Je(l,"day",hr),m=Tt("day",d),u=ut(l,"auto",hr,m);yt(u,d);const f=Oe(l,"trunc"),y=ft(l,void 0,!1),g=Ot(r,this,n,de(Q({},l),{largestUnit:u}));if(d==="day"&&y===1)return g;let{years:w,months:p,weeks:v,days:T}=g;return{years:w,months:p,weeks:v,days:T}=gt(w,p,v,T,0,0,0,0,0,0,y,d,f,this),new(x("%Temporal.Duration%"))(w,p,v,T,0,0,0,0,0,0)}since(e,t){if(!X(this))throw new TypeError("invalid receiver");const n=ce(e),r=o(this,E),s=o(n,E),a=L(r),c=L(s);if(a!==c)throw new RangeError(`cannot compute difference between dates of ${a} and ${c} calendars`);const l=z(t),d=Je(l,"day",hr),m=Tt("day",d),u=ut(l,"auto",hr,m);yt(u,d);const f=Oe(l,"trunc"),y=ft(l,void 0,!1),g=de(Q({},l),{largestUnit:u});let{years:w,months:p,weeks:v,days:T}=Ot(r,this,n,g);const b=x("%Temporal.Duration%");return d==="day"&&y===1||({years:w,months:p,weeks:v,days:T}=gt(w,p,v,T,0,0,0,0,0,0,y,d,Kn(f),this)),new b(-w,-p,-v,-T,0,0,0,0,0,0)}equals(e){if(!X(this))throw new TypeError("invalid receiver");const t=ce(e);for(const n of[O,$,I])if(o(this,n)!==o(t,n))return!1;return rr(o(this,E),o(t,E))}toString(e){if(!X(this))throw new TypeError("invalid receiver");return ei(this,Jn(z(e)))}toJSON(){if(!X(this))throw new TypeError("invalid receiver");return ei(this)}toLocaleString(e,t){if(!X(this))throw new TypeError("invalid receiver");return new Xt(e,t).format(this)}valueOf(){throw new TypeError("use compare() or equals() to compare Temporal.PlainDate")}toPlainDateTime(e){if(!X(this))throw new TypeError("invalid receiver");const t=o(this,O),n=o(this,$),r=o(this,I),s=o(this,E);if(e===void 0)return rt(t,n,r,0,0,0,0,0,0,s);const a=Mt(e);return rt(t,n,r,o(a,Z),o(a,j),o(a,A),o(a,q),o(a,U),o(a,S),s)}toZonedDateTime(e){if(!X(this))throw new TypeError("invalid receiver");let t,n;if(ue(e)){const g=e.timeZone;g===void 0?t=nt(e):(t=nt(g),n=e.plainTime)}else t=nt(e);const r=o(this,O),s=o(this,$),a=o(this,I),c=o(this,E);let l=0,d=0,m=0,u=0,f=0,y=0;return n!==void 0&&(n=Mt(n),l=o(n,Z),d=o(n,j),m=o(n,A),u=o(n,q),f=o(n,U),y=o(n,S)),Fe(o(tt(t,rt(r,s,a,l,d,m,u,f,y,c),"compatible"),P),t,c)}toPlainYearMonth(){if(!X(this))throw new TypeError("invalid receiver");const e=o(this,E);return Ht(e,it(this,Ee(e,["monthCode","year"])))}toPlainMonthDay(){if(!X(this))throw new TypeError("invalid receiver");const e=o(this,E);return Dn(e,en(this,Ee(e,["day","monthCode"])))}getISOFields(){if(!X(this))throw new TypeError("invalid receiver");return{calendar:o(this,E),isoDay:o(this,I),isoMonth:o(this,$),isoYear:o(this,O)}}static from(e,t){const n=z(t);return X(e)?(Le(n),Et(o(e,O),o(e,$),o(e,I),o(e,E))):ce(e,n)}static compare(e,t){const n=ce(e),r=ce(t);return Lt(o(n,O),o(n,$),o(n,I),o(r,O),o(r,$),o(r,I))}}Yt(ir,"Temporal.PlainDate");class sr{constructor(e,t,n,r=0,s=0,a=0,c=0,l=0,d=0,m=Ce()){const u=he(e),f=he(t),y=he(n),g=he(r),w=he(s),p=he(a),v=he(c),T=he(l),b=he(d),D=Ae(m);if(arguments.length<3)throw new RangeError("missing argument: isoYear, isoMonth and isoDay are required");Fi(this,u,f,y,g,w,p,v,T,b,D)}get calendar(){if(!H(this))throw new TypeError("invalid receiver");return o(this,E)}get year(){if(!H(this))throw new TypeError("invalid receiver");return kr(o(this,E),this)}get month(){if(!H(this))throw new TypeError("invalid receiver");return Ir(o(this,E),this)}get monthCode(){if(!H(this))throw new TypeError("invalid receiver");return nr(o(this,E),this)}get day(){if(!H(this))throw new TypeError("invalid receiver");return Yr(o(this,E),this)}get hour(){if(!H(this))throw new TypeError("invalid receiver");return o(this,Z)}get minute(){if(!H(this))throw new TypeError("invalid receiver");return o(this,j)}get second(){if(!H(this))throw new TypeError("invalid receiver");return o(this,A)}get millisecond(){if(!H(this))throw new TypeError("invalid receiver");return o(this,q)}get microsecond(){if(!H(this))throw new TypeError("invalid receiver");return o(this,U)}get nanosecond(){if(!H(this))throw new TypeError("invalid receiver");return o(this,S)}get era(){if(!H(this))throw new TypeError("invalid receiver");return Nr(o(this,E),this)}get eraYear(){if(!H(this))throw new TypeError("invalid receiver");return Pr(o(this,E),this)}get dayOfWeek(){if(!H(this))throw new TypeError("invalid receiver");return bo(o(this,E),this)}get dayOfYear(){if(!H(this))throw new TypeError("invalid receiver");return Do(o(this,E),this)}get weekOfYear(){if(!H(this))throw new TypeError("invalid receiver");return _o(o(this,E),this)}get daysInWeek(){if(!H(this))throw new TypeError("invalid receiver");return Co(o(this,E),this)}get daysInYear(){if(!H(this))throw new TypeError("invalid receiver");return Fr(o(this,E),this)}get daysInMonth(){if(!H(this))throw new TypeError("invalid receiver");return wn(o(this,E),this)}get monthsInYear(){if(!H(this))throw new TypeError("invalid receiver");return xr(o(this,E),this)}get inLeapYear(){if(!H(this))throw new TypeError("invalid receiver");return Lr(o(this,E),this)}with(e,t){if(!H(this))throw new TypeError("invalid receiver");if(!ue(e))throw new TypeError("invalid argument");$n(e);const n=z(t),r=o(this,E),s=Ee(r,["day","hour","microsecond","millisecond","minute","month","monthCode","nanosecond","second","year"]),a=Bt(e,s);if(!a)throw new TypeError("invalid date-time-like");let c=vr(this,s);c=sn(r,c,a),c=vr(c,s);const{year:l,month:d,day:m,hour:u,minute:f,second:y,millisecond:g,microsecond:w,nanosecond:p}=tr(r,c,n);return rt(l,d,m,u,f,y,g,w,p,r)}withPlainTime(e){if(!H(this))throw new TypeError("invalid receiver");const t=o(this,O),n=o(this,$),r=o(this,I),s=o(this,E);if(e===void 0)return rt(t,n,r,0,0,0,0,0,0,s);const a=Mt(e);return rt(t,n,r,o(a,Z),o(a,j),o(a,A),o(a,q),o(a,U),o(a,S),s)}withPlainDate(e){if(!H(this))throw new TypeError("invalid receiver");const t=ce(e),n=o(t,O),r=o(t,$),s=o(t,I);let a=o(t,E);const c=o(this,Z),l=o(this,j),d=o(this,A),m=o(this,q),u=o(this,U),f=o(this,S);return a=ji(o(this,E),a),rt(n,r,s,c,l,d,m,u,f,a)}withCalendar(e){if(!H(this))throw new TypeError("invalid receiver");const t=Ae(e);return new sr(o(this,O),o(this,$),o(this,I),o(this,Z),o(this,j),o(this,A),o(this,q),o(this,U),o(this,S),t)}add(e,t){if(!H(this))throw new TypeError("invalid receiver");const n=vt(e),{years:r,months:s,weeks:a,days:c,hours:l,minutes:d,seconds:m,milliseconds:u,microseconds:f,nanoseconds:y}=n,g=z(t),w=o(this,E),{year:p,month:v,day:T,hour:b,minute:D,second:_,millisecond:C,microsecond:M,nanosecond:k}=Cr(o(this,O),o(this,$),o(this,I),o(this,Z),o(this,j),o(this,A),o(this,q),o(this,U),o(this,S),w,r,s,a,c,l,d,m,u,f,y,g);return rt(p,v,T,b,D,_,C,M,k,w)}subtract(e,t){if(!H(this))throw new TypeError("invalid receiver");const n=vt(e),{years:r,months:s,weeks:a,days:c,hours:l,minutes:d,seconds:m,milliseconds:u,microseconds:f,nanoseconds:y}=n,g=z(t),w=o(this,E),{year:p,month:v,day:T,hour:b,minute:D,second:_,millisecond:C,microsecond:M,nanosecond:k}=Cr(o(this,O),o(this,$),o(this,I),o(this,Z),o(this,j),o(this,A),o(this,q),o(this,U),o(this,S),w,-r,-s,-a,-c,-l,-d,-m,-u,-f,-y,g);return rt(p,v,T,b,D,_,C,M,k,w)}until(e,t){if(!H(this))throw new TypeError("invalid receiver");const n=St(e),r=o(this,E),s=o(n,E),a=L(r),c=L(s);if(a!==c)throw new RangeError(`cannot compute difference between dates of ${a} and ${c} calendars`);const l=z(t),d=Je(l,"nanosecond"),m=ut(l,"auto",[],Tt("day",d));yt(m,d);const u=Oe(l,"trunc"),f=Sn(l,d);let{years:y,months:g,weeks:w,days:p,hours:v,minutes:T,seconds:b,milliseconds:D,microseconds:_,nanoseconds:C}=Dr(o(this,O),o(this,$),o(this,I),o(this,Z),o(this,j),o(this,A),o(this,q),o(this,U),o(this,S),o(n,O),o(n,$),o(n,I),o(n,Z),o(n,j),o(n,A),o(n,q),o(n,U),o(n,S),r,m,l);const M=tn(this);return{years:y,months:g,weeks:w,days:p,hours:v,minutes:T,seconds:b,milliseconds:D,microseconds:_,nanoseconds:C}=gt(y,g,w,p,v,T,b,D,_,C,f,d,u,M),{days:p,hours:v,minutes:T,seconds:b,milliseconds:D,microseconds:_,nanoseconds:C}=je(p,v,T,b,D,_,C,m),new(x("%Temporal.Duration%"))(y,g,w,p,v,T,b,D,_,C)}since(e,t){if(!H(this))throw new TypeError("invalid receiver");const n=St(e),r=o(this,E),s=o(n,E),a=L(r),c=L(s);if(a!==c)throw new RangeError(`cannot compute difference between dates of ${a} and ${c} calendars`);const l=z(t),d=Je(l,"nanosecond"),m=ut(l,"auto",[],Tt("day",d));yt(m,d);const u=Oe(l,"trunc"),f=Sn(l,d);let{years:y,months:g,weeks:w,days:p,hours:v,minutes:T,seconds:b,milliseconds:D,microseconds:_,nanoseconds:C}=Dr(o(this,O),o(this,$),o(this,I),o(this,Z),o(this,j),o(this,A),o(this,q),o(this,U),o(this,S),o(n,O),o(n,$),o(n,I),o(n,Z),o(n,j),o(n,A),o(n,q),o(n,U),o(n,S),r,m,l);const M=tn(this);return{years:y,months:g,weeks:w,days:p,hours:v,minutes:T,seconds:b,milliseconds:D,microseconds:_,nanoseconds:C}=gt(y,g,w,p,v,T,b,D,_,C,f,d,Kn(u),M),{days:p,hours:v,minutes:T,seconds:b,milliseconds:D,microseconds:_,nanoseconds:C}=je(p,v,T,b,D,_,C,m),new(x("%Temporal.Duration%"))(-y,-g,-w,-p,-v,-T,-b,-D,-_,-C)}round(e){if(!H(this))throw new TypeError("invalid receiver");if(e===void 0)throw new TypeError("options parameter is required");const t=typeof e=="string"?Cn("smallestUnit",e):z(e),n=Je(t,void 0,["year","month","week"]);if(n===void 0)throw new RangeError("smallestUnit is required");const r=Oe(t,"halfExpand"),s=ft(t,{day:1,hour:24,minute:60,second:60,millisecond:1e3,microsecond:1e3,nanosecond:1e3}[n],!1);let a=o(this,O),c=o(this,$),l=o(this,I),d=o(this,Z),m=o(this,j),u=o(this,A),f=o(this,q),y=o(this,U),g=o(this,S);return{year:a,month:c,day:l,hour:d,minute:m,second:u,millisecond:f,microsecond:y,nanosecond:g}=Io(a,c,l,d,m,u,f,y,g,s,n,r),rt(a,c,l,d,m,u,f,y,g,o(this,E))}equals(e){if(!H(this))throw new TypeError("invalid receiver");const t=St(e);for(const n of[O,$,I,Z,j,A,q,U,S])if(o(this,n)!==o(t,n))return!1;return rr(o(this,E),o(t,E))}toString(e){if(!H(this))throw new TypeError("invalid receiver");const t=z(e),{precision:n,unit:r,increment:s}=er(t);return ti(this,n,Jn(t),{unit:r,increment:s,roundingMode:Oe(t,"trunc")})}toJSON(){if(!H(this))throw new TypeError("invalid receiver");return ti(this,"auto")}toLocaleString(e,t){if(!H(this))throw new TypeError("invalid receiver");return new Xt(e,t).format(this)}valueOf(){throw new TypeError("use compare() or equals() to compare Temporal.PlainDateTime")}toZonedDateTime(e,t){if(!H(this))throw new TypeError("invalid receiver");const n=nt(e);return Fe(o(tt(n,this,Un(z(t))),P),n,o(this,E))}toPlainDate(){if(!H(this))throw new TypeError("invalid receiver");return tn(this)}toPlainYearMonth(){if(!H(this))throw new TypeError("invalid receiver");const e=o(this,E);return Ht(e,it(this,Ee(e,["monthCode","year"])))}toPlainMonthDay(){if(!H(this))throw new TypeError("invalid receiver");const e=o(this,E);return Dn(e,en(this,Ee(e,["day","monthCode"])))}toPlainTime(){if(!H(this))throw new TypeError("invalid receiver");return Mo(this)}getISOFields(){if(!H(this))throw new TypeError("invalid receiver");return{calendar:o(this,E),isoDay:o(this,I),isoHour:o(this,Z),isoMicrosecond:o(this,U),isoMillisecond:o(this,q),isoMinute:o(this,j),isoMonth:o(this,$),isoNanosecond:o(this,S),isoSecond:o(this,A),isoYear:o(this,O)}}static from(e,t){const n=z(t);return H(e)?(Le(n),rt(o(e,O),o(e,$),o(e,I),o(e,Z),o(e,j),o(e,A),o(e,q),o(e,U),o(e,S),o(e,E))):St(e,n)}static compare(e,t){const n=St(e),r=St(t);for(const s of[O,$,I,Z,j,A,q,U,S]){const a=o(n,s),c=o(r,s);if(a!==c)return rn(a-c)}return 0}}Yt(sr,"Temporal.PlainDateTime");class Rt{constructor(e=0,t=0,n=0,r=0,s=0,a=0,c=0,l=0,d=0,m=0){const u=Pe(e),f=Pe(t),y=Pe(n),g=Pe(r),w=Pe(s),p=Pe(a),v=Pe(c),T=Pe(l),b=Pe(d),D=Pe(m),_=pt(u,f,y,g,w,p,v,T,b,D);for(const C of[u,f,y,g,w,p,v,T,b,D]){if(!Number.isFinite(C))throw new RangeError("infinite values not allowed as duration fields");const M=Math.sign(C);if(M!==0&&M!==_)throw new RangeError("mixed-sign values not allowed as duration fields")}Nt(this),W(this,Se,u),W(this,$e,f),W(this,et,y),W(this,ze,g),W(this,Ge,w),W(this,He,p),W(this,We,v),W(this,Ve,T),W(this,Be,b),W(this,Xe,D)}get years(){if(!pe(this))throw new TypeError("invalid receiver");return o(this,Se)}get months(){if(!pe(this))throw new TypeError("invalid receiver");return o(this,$e)}get weeks(){if(!pe(this))throw new TypeError("invalid receiver");return o(this,et)}get days(){if(!pe(this))throw new TypeError("invalid receiver");return o(this,ze)}get hours(){if(!pe(this))throw new TypeError("invalid receiver");return o(this,Ge)}get minutes(){if(!pe(this))throw new TypeError("invalid receiver");return o(this,He)}get seconds(){if(!pe(this))throw new TypeError("invalid receiver");return o(this,We)}get milliseconds(){if(!pe(this))throw new TypeError("invalid receiver");return o(this,Ve)}get microseconds(){if(!pe(this))throw new TypeError("invalid receiver");return o(this,Be)}get nanoseconds(){if(!pe(this))throw new TypeError("invalid receiver");return o(this,Xe)}get sign(){if(!pe(this))throw new TypeError("invalid receiver");return pt(o(this,Se),o(this,$e),o(this,et),o(this,ze),o(this,Ge),o(this,He),o(this,We),o(this,Ve),o(this,Be),o(this,Xe))}get blank(){if(!pe(this))throw new TypeError("invalid receiver");return pt(o(this,Se),o(this,$e),o(this,et),o(this,ze),o(this,Ge),o(this,He),o(this,We),o(this,Ve),o(this,Be),o(this,Xe))===0}with(e){if(!pe(this))throw new TypeError("invalid receiver");const t=Bt(e,["days","hours","microseconds","milliseconds","minutes","months","nanoseconds","seconds","weeks","years"]);if(!t)throw new TypeError("invalid duration-like");const{years:n=o(this,Se),months:r=o(this,$e),weeks:s=o(this,et),days:a=o(this,ze),hours:c=o(this,Ge),minutes:l=o(this,He),seconds:d=o(this,We),milliseconds:m=o(this,Ve),microseconds:u=o(this,Be),nanoseconds:f=o(this,Xe)}=t;return new Rt(n,r,s,a,c,l,d,m,u,f)}negated(){if(!pe(this))throw new TypeError("invalid receiver");return Wi(this)}abs(){if(!pe(this))throw new TypeError("invalid receiver");return new Rt(Math.abs(o(this,Se)),Math.abs(o(this,$e)),Math.abs(o(this,et)),Math.abs(o(this,ze)),Math.abs(o(this,Ge)),Math.abs(o(this,He)),Math.abs(o(this,We)),Math.abs(o(this,Ve)),Math.abs(o(this,Be)),Math.abs(o(this,Xe)))}add(e,t){if(!pe(this))throw new TypeError("invalid receiver");let{years:n,months:r,weeks:s,days:a,hours:c,minutes:l,seconds:d,milliseconds:m,microseconds:u,nanoseconds:f}=vt(e);const y=In(z(t));return{years:n,months:r,weeks:s,days:a,hours:c,minutes:l,seconds:d,milliseconds:m,microseconds:u,nanoseconds:f}=ho(o(this,Se),o(this,$e),o(this,et),o(this,ze),o(this,Ge),o(this,He),o(this,We),o(this,Ve),o(this,Be),o(this,Xe),n,r,s,a,c,l,d,m,u,f,y),new Rt(n,r,s,a,c,l,d,m,u,f)}subtract(e,t){if(!pe(this))throw new TypeError("invalid receiver");let{years:n,months:r,weeks:s,days:a,hours:c,minutes:l,seconds:d,milliseconds:m,microseconds:u,nanoseconds:f}=vt(e);const y=In(z(t));return{years:n,months:r,weeks:s,days:a,hours:c,minutes:l,seconds:d,milliseconds:m,microseconds:u,nanoseconds:f}=ho(o(this,Se),o(this,$e),o(this,et),o(this,ze),o(this,Ge),o(this,He),o(this,We),o(this,Ve),o(this,Be),o(this,Xe),-n,-r,-s,-a,-c,-l,-d,-m,-u,-f,y),new Rt(n,r,s,a,c,l,d,m,u,f)}round(e){if(!pe(this))throw new TypeError("invalid receiver");if(e===void 0)throw new TypeError("options parameter is required");let t=o(this,Se),n=o(this,$e),r=o(this,et),s=o(this,ze),a=o(this,Ge),c=o(this,He),l=o(this,We),d=o(this,Ve),m=o(this,Be),u=o(this,Xe),f=ro(t,n,r,s,a,c,l,d,m,u);const y=typeof e=="string"?Cn("smallestUnit",e):z(e);let g=Je(y,void 0),w=!0;g||(w=!1,g="nanosecond"),f=Tt(f,g);let p=ut(y,void 0),v=!0;if(p||(v=!1,p=f),p==="auto"&&(p=f),!w&&!v)throw new RangeError("at least one of smallestUnit or largestUnit is required");yt(p,g);const T=Oe(y,"halfExpand"),b=Sn(y,g);let D=In(y);return{years:t,months:n,weeks:r,days:s}=cr(t,n,r,s,p,D),{years:t,months:n,weeks:r,days:s,hours:a,minutes:c,seconds:l,milliseconds:d,microseconds:m,nanoseconds:u}=gt(t,n,r,s,a,c,l,d,m,u,b,g,T,D),{years:t,months:n,weeks:r,days:s,hours:a,minutes:c,seconds:l,milliseconds:d,microseconds:m,nanoseconds:u}=uo(t,n,r,s,a,c,l,d,m,u,b,g,T,D),{years:t,months:n,weeks:r,days:s}=function(C,M,k,N,J,K){let V=C,F=M,G=k,R=N;const B=x("%Temporal.Duration%"),se=pt(V,F,G,R,0,0,0,0,0,0);if(se===0)return{years:V,months:F,weeks:G,days:R};let re,ae;K&&(ae=ce(K),re=o(ae,E));const we=new B(se),ot=new B(0,se),wt=new B(0,0,se);switch(J){case"year":{if(!re)throw new RangeError("a starting point is required for years balancing");let Te,Me,ln;for({relativeTo:Te,days:Me}=Qe(re,ae,we);te(R)>=te(Me);)R-=Me,V+=se,ae=Te,{relativeTo:Te,days:Me}=Qe(re,ae,we);for({relativeTo:Te,days:ln}=Qe(re,ae,ot);te(R)>=te(ln);)R-=ln,F+=se,ae=Te,{relativeTo:Te,days:ln}=Qe(re,ae,ot);const Ao=re.dateAdd;Te=Ke(re,ae,we,le(null),Ao);const qo=re.dateUntil,Uo=le(null);Uo.largestUnit="month";let Ur=Ot(re,ae,Te,Uo,qo),Sr=o(Ur,$e);for(;te(F)>=te(Sr);){F-=Sr,V+=se,ae=Te,Te=Ke(re,ae,we,le(null),Ao);const So=le(null);So.largestUnit="month",Ur=Ot(re,ae,Te,So,qo),Sr=o(Ur,$e)}break}case"month":{if(!re)throw new RangeError("a starting point is required for months balancing");let Te,Me;for({relativeTo:Te,days:Me}=Qe(re,ae,ot);te(R)>=te(Me);)R-=Me,F+=se,ae=Te,{relativeTo:Te,days:Me}=Qe(re,ae,ot);break}case"week":{if(!re)throw new RangeError("a starting point is required for weeks balancing");let Te,Me;for({relativeTo:Te,days:Me}=Qe(re,ae,wt);te(R)>=te(Me);)R-=Me,G+=se,ae=Te,{relativeTo:Te,days:Me}=Qe(re,ae,wt);break}}return{years:V,months:F,weeks:G,days:R}}(t,n,r,s,p,D),Y(D)&&(D=lo(D,t,n,r,0)),{days:s,hours:a,minutes:c,seconds:l,milliseconds:d,microseconds:m,nanoseconds:u}=je(s,a,c,l,d,m,u,p,D),new Rt(t,n,r,s,a,c,l,d,m,u)}total(e){if(!pe(this))throw new TypeError("invalid receiver");let t=o(this,Se),n=o(this,$e),r=o(this,et),s=o(this,ze),a=o(this,Ge),c=o(this,He),l=o(this,We),d=o(this,Ve),m=o(this,Be),u=o(this,Xe);if(e===void 0)throw new TypeError("options argument is required");const f=typeof e=="string"?Cn("unit",e):z(e),y=function(T){const b=new Map($r),D=kt(T,"unit",[...b.values(),...b.keys()],void 0);return b.has(D)?b.get(D):D}(f);if(y===void 0)throw new RangeError("unit option is required");const g=In(f);let w;({years:t,months:n,weeks:r,days:s}=cr(t,n,r,s,y,g)),Y(g)&&(w=lo(g,t,n,r,0)),{days:s,hours:a,minutes:c,seconds:l,milliseconds:d,microseconds:m,nanoseconds:u}=je(s,a,c,l,d,m,u,y,w);const{total:p}=gt(t,n,r,s,a,c,l,d,m,u,1,y,"trunc",g);return p}toString(e){if(!pe(this))throw new TypeError("invalid receiver");const t=z(e),{precision:n,unit:r,increment:s}=er(t);if(n==="minute")throw new RangeError('smallestUnit must not be "minute"');return Wr(this,n,{unit:r,increment:s,roundingMode:Oe(t,"trunc")})}toJSON(){if(!pe(this))throw new TypeError("invalid receiver");return Wr(this)}toLocaleString(e,t){if(!pe(this))throw new TypeError("invalid receiver");return typeof Intl!="undefined"&&Intl.DurationFormat!==void 0?new Intl.DurationFormat(e,t).format(this):(console.warn("Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat."),Wr(this))}valueOf(){throw new TypeError("use compare() to compare Temporal.Duration")}static from(e){return pe(e)?new Rt(o(e,Se),o(e,$e),o(e,et),o(e,ze),o(e,Ge),o(e,He),o(e,We),o(e,Ve),o(e,Be),o(e,Xe)):gn(e)}static compare(e,t,n){const r=gn(e),s=gn(t),a=In(z(n)),c=o(r,Se),l=o(r,$e),d=o(r,et);let m=o(r,ze);const u=o(r,Ge),f=o(r,He),y=o(r,We),g=o(r,Ve),w=o(r,Be);let p=o(r,Xe);const v=o(s,Se),T=o(s,$e),b=o(s,et);let D=o(s,ze);const _=o(s,Ge),C=o(s,He),M=o(s,We),k=o(s,Ve),N=o(s,Be);let J=o(s,Xe);const K=si(a,c,l,d,m,u,f,y,g,w,p),V=si(a,v,T,b,D,_,C,M,k,N,J);c===0&&v===0&&l===0&&T===0&&d===0&&b===0||({days:m}=cr(c,l,d,m,"day",a),{days:D}=cr(v,T,b,D,"day",a));const F=_n(m,u,f,y,g,w,p,K),G=_n(D,_,C,M,k,N,J,V);return rn(h.toNumber(h.subtract(F,G)))}}Yt(Rt,"Temporal.Duration");const la=Object.create;class Fo{constructor(e,t,n=Ce(),r=1972){const s=he(e),a=he(t),c=Ae(n),l=he(r);if(arguments.length<2)throw new RangeError("missing argument: isoMonth and isoDay are required");xi(this,s,a,c,l)}get monthCode(){if(!Ne(this))throw new TypeError("invalid receiver");return nr(o(this,E),this)}get day(){if(!Ne(this))throw new TypeError("invalid receiver");return Yr(o(this,E),this)}get calendar(){if(!Ne(this))throw new TypeError("invalid receiver");return o(this,E)}with(e,t){if(!Ne(this))throw new TypeError("invalid receiver");if(!ue(e))throw new TypeError("invalid argument");$n(e);const n=o(this,E),r=Ee(n,["day","month","monthCode","year"]),s=Bt(e,r);if(!s)throw new TypeError("invalid month-day-like");let a=en(this,r);return a=sn(n,a,s),a=en(a,r),Dn(n,a,z(t))}equals(e){if(!Ne(this))throw new TypeError("invalid receiver");const t=Ko(e);for(const n of[$,I,O])if(o(this,n)!==o(t,n))return!1;return rr(o(this,E),o(t,E))}toString(e){if(!Ne(this))throw new TypeError("invalid receiver");return ni(this,Jn(z(e)))}toJSON(){if(!Ne(this))throw new TypeError("invalid receiver");return ni(this)}toLocaleString(e,t){if(!Ne(this))throw new TypeError("invalid receiver");return new Xt(e,t).format(this)}valueOf(){throw new TypeError("use equals() to compare Temporal.PlainMonthDay")}toPlainDate(e){if(!Ne(this))throw new TypeError("invalid receiver");if(!ue(e))throw new TypeError("argument should be an object");const t=o(this,E),n=Ee(t,["day","monthCode"]),r=en(this,n),s=Ee(t,["year"]),a=[["year",void 0]];s.forEach(u=>{a.some(([f])=>f===u)||a.push([u,void 0])});let c=sn(t,r,Ze(e,a));const l=[...new Set([...n,...s])],d=[];l.forEach(u=>{d.some(([f])=>f===u)||d.push([u,void 0])}),c=Ze(c,d);const m=la(null);return m.overflow="reject",bt(t,c,m)}getISOFields(){if(!Ne(this))throw new TypeError("invalid receiver");return{calendar:o(this,E),isoDay:o(this,I),isoMonth:o(this,$),isoYear:o(this,O)}}static from(e,t){const n=z(t);return Ne(e)?(Le(n),zn(o(e,$),o(e,I),o(e,E),o(e,O))):Ko(e,n)}}Yt(Fo,"Temporal.PlainMonthDay");const xo=()=>new(x("%Temporal.Instant%"))(No()),ci=(i,e=zt())=>{const t=nt(e),n=Ae(i);return mt(t,xo(),n)},Xr=(i=zt())=>{const e=nt(i),t=Ce();return mt(e,xo(),t)},hi=(i,e=zt())=>{const t=nt(e),n=Ae(i);return Fe(No(),t,n)},zt=()=>function(){const e=new Di("en-us");return new(x("%Temporal.TimeZone%"))($i(e.resolvedOptions().timeZone))}(),ls={instant:xo,plainDateTime:ci,plainDateTimeISO:Xr,plainDate:(i,e=zt())=>tn(ci(i,e)),plainDateISO:(i=zt())=>tn(Xr(i)),plainTimeISO:(i=zt())=>Mo(Xr(i)),timeZone:zt,zonedDateTime:hi,zonedDateTimeISO:(i=zt())=>hi(Ce(),i),[Symbol.toStringTag]:"Temporal.Now"};Object.defineProperty(ls,Symbol.toStringTag,{value:"Temporal.Now",writable:!1,enumerable:!1,configurable:!0});const da=Object.assign,Pn=["year","month","week","day"],Qr={hour:24,minute:60,second:60,millisecond:1e3,microsecond:1e3,nanosecond:1e3};function li(i,e,t){let n=o(i,Z),r=o(i,j),s=o(i,A),a=o(i,q),c=o(i,U),l=o(i,S);if(t){const{unit:d,increment:m,roundingMode:u}=t;({hour:n,minute:r,second:s,millisecond:a,microsecond:c,nanosecond:l}=Yo(n,r,s,a,c,l,m,d,u))}return`${fe(n)}:${fe(r)}${Zr(s,a,c,l,e)}`}class Zt{constructor(e=0,t=0,n=0,r=0,s=0,a=0){const c=he(e),l=he(t),d=he(n),m=he(r),u=he(s),f=he(a);jr(c,l,d,m,u,f),Nt(this),W(this,Z,c),W(this,j,l),W(this,A,d),W(this,q,m),W(this,U,u),W(this,S,f),W(this,E,Ce())}get calendar(){if(!ve(this))throw new TypeError("invalid receiver");return o(this,E)}get hour(){if(!ve(this))throw new TypeError("invalid receiver");return o(this,Z)}get minute(){if(!ve(this))throw new TypeError("invalid receiver");return o(this,j)}get second(){if(!ve(this))throw new TypeError("invalid receiver");return o(this,A)}get millisecond(){if(!ve(this))throw new TypeError("invalid receiver");return o(this,q)}get microsecond(){if(!ve(this))throw new TypeError("invalid receiver");return o(this,U)}get nanosecond(){if(!ve(this))throw new TypeError("invalid receiver");return o(this,S)}with(e,t){if(!ve(this))throw new TypeError("invalid receiver");if(!ue(e))throw new TypeError("invalid argument");$n(e);const n=Le(z(t)),r=Bt(e,["hour","microsecond","millisecond","minute","nanosecond","second"]);if(!r)throw new TypeError("invalid time-like");const s=Eo(this);let{hour:a,minute:c,second:l,millisecond:d,microsecond:m,nanosecond:u}=da(s,r);return{hour:a,minute:c,second:l,millisecond:d,microsecond:m,nanosecond:u}=Fn(a,c,l,d,m,u,n),new Zt(a,c,l,d,m,u)}add(e){if(!ve(this))throw new TypeError("invalid receiver");const t=vt(e),{hours:n,minutes:r,seconds:s,milliseconds:a,microseconds:c,nanoseconds:l}=t;let d=o(this,Z),m=o(this,j),u=o(this,A),f=o(this,q),y=o(this,U),g=o(this,S);return{hour:d,minute:m,second:u,millisecond:f,microsecond:y,nanosecond:g}=co(d,m,u,f,y,g,n,r,s,a,c,l),{hour:d,minute:m,second:u,millisecond:f,microsecond:y,nanosecond:g}=Fn(d,m,u,f,y,g,"reject"),new Zt(d,m,u,f,y,g)}subtract(e){if(!ve(this))throw new TypeError("invalid receiver");const t=vt(e),{hours:n,minutes:r,seconds:s,milliseconds:a,microseconds:c,nanoseconds:l}=t;let d=o(this,Z),m=o(this,j),u=o(this,A),f=o(this,q),y=o(this,U),g=o(this,S);return{hour:d,minute:m,second:u,millisecond:f,microsecond:y,nanosecond:g}=co(d,m,u,f,y,g,-n,-r,-s,-a,-c,-l),{hour:d,minute:m,second:u,millisecond:f,microsecond:y,nanosecond:g}=Fn(d,m,u,f,y,g,"reject"),new Zt(d,m,u,f,y,g)}until(e,t){if(!ve(this))throw new TypeError("invalid receiver");const n=Mt(e),r=z(t),s=ut(r,"auto",Pn,"hour"),a=Je(r,"nanosecond",Pn);yt(s,a);const c=Oe(r,"trunc"),l=ft(r,Qr[a],!1);let{hours:d,minutes:m,seconds:u,milliseconds:f,microseconds:y,nanoseconds:g}=so(o(this,Z),o(this,j),o(this,A),o(this,q),o(this,U),o(this,S),o(n,Z),o(n,j),o(n,A),o(n,q),o(n,U),o(n,S));return{hours:d,minutes:m,seconds:u,milliseconds:f,microseconds:y,nanoseconds:g}=gt(0,0,0,0,d,m,u,f,y,g,l,a,c),{hours:d,minutes:m,seconds:u,milliseconds:f,microseconds:y,nanoseconds:g}=je(0,d,m,u,f,y,g,s),new(x("%Temporal.Duration%"))(0,0,0,0,d,m,u,f,y,g)}since(e,t){if(!ve(this))throw new TypeError("invalid receiver");const n=Mt(e),r=z(t),s=ut(r,"auto",Pn,"hour"),a=Je(r,"nanosecond",Pn);yt(s,a);const c=Oe(r,"trunc"),l=ft(r,Qr[a],!1);let{hours:d,minutes:m,seconds:u,milliseconds:f,microseconds:y,nanoseconds:g}=so(o(n,Z),o(n,j),o(n,A),o(n,q),o(n,U),o(n,S),o(this,Z),o(this,j),o(this,A),o(this,q),o(this,U),o(this,S));return{hours:d,minutes:m,seconds:u,milliseconds:f,microseconds:y,nanoseconds:g}=gt(0,0,0,0,-d,-m,-u,-f,-y,-g,l,a,Kn(c)),d=-d,m=-m,u=-u,f=-f,y=-y,g=-g,{hours:d,minutes:m,seconds:u,milliseconds:f,microseconds:y,nanoseconds:g}=je(0,d,m,u,f,y,g,s),new(x("%Temporal.Duration%"))(0,0,0,0,d,m,u,f,y,g)}round(e){if(!ve(this))throw new TypeError("invalid receiver");if(e===void 0)throw new TypeError("options parameter is required");const t=typeof e=="string"?Cn("smallestUnit",e):z(e),n=Je(t,void 0,Pn);if(n===void 0)throw new RangeError("smallestUnit is required");const r=Oe(t,"halfExpand"),s=ft(t,Qr[n],!1);let a=o(this,Z),c=o(this,j),l=o(this,A),d=o(this,q),m=o(this,U),u=o(this,S);return{hour:a,minute:c,second:l,millisecond:d,microsecond:m,nanosecond:u}=Yo(a,c,l,d,m,u,s,n,r),new Zt(a,c,l,d,m,u)}equals(e){if(!ve(this))throw new TypeError("invalid receiver");const t=Mt(e);for(const n of[Z,j,A,q,U,S])if(o(this,n)!==o(t,n))return!1;return!0}toString(e){if(!ve(this))throw new TypeError("invalid receiver");const t=z(e),{precision:n,unit:r,increment:s}=er(t);return li(this,n,{unit:r,increment:s,roundingMode:Oe(t,"trunc")})}toJSON(){if(!ve(this))throw new TypeError("invalid receiver");return li(this,"auto")}toLocaleString(e,t){if(!ve(this))throw new TypeError("invalid receiver");return new Xt(e,t).format(this)}valueOf(){throw new TypeError("use compare() or equals() to compare Temporal.PlainTime")}toPlainDateTime(e){if(!ve(this))throw new TypeError("invalid receiver");const t=ce(e),n=o(t,O),r=o(t,$),s=o(t,I),a=o(t,E);return rt(n,r,s,o(this,Z),o(this,j),o(this,A),o(this,q),o(this,U),o(this,S),a)}toZonedDateTime(e){if(!ve(this))throw new TypeError("invalid receiver");if(!ue(e))throw new TypeError("invalid argument");const t=e.plainDate;if(t===void 0)throw new TypeError("missing date property");const n=ce(t),r=e.timeZone;if(r===void 0)throw new TypeError("missing timeZone property");const s=nt(r),a=o(n,O),c=o(n,$),l=o(n,I),d=o(n,E),m=o(this,Z),u=o(this,j),f=o(this,A),y=o(this,q),g=o(this,U),w=o(this,S);return Fe(o(tt(s,new(x("%Temporal.PlainDateTime%"))(a,c,l,m,u,f,y,g,w,d),"compatible"),P),s,d)}getISOFields(){if(!ve(this))throw new TypeError("invalid receiver");return{calendar:o(this,E),isoHour:o(this,Z),isoMicrosecond:o(this,U),isoMillisecond:o(this,q),isoMinute:o(this,j),isoNanosecond:o(this,S),isoSecond:o(this,A)}}static from(e,t){const n=Le(z(t));return ve(e)?new Zt(o(e,Z),o(e,j),o(e,A),o(e,q),o(e,U),o(e,S)):Mt(e,n)}static compare(e,t){const n=Mt(e),r=Mt(t);for(const s of[Z,j,A,q,U,S]){const a=o(n,s),c=o(r,s);if(a!==c)return rn(a-c)}return 0}}Yt(Zt,"Temporal.PlainTime");class Lo{constructor(e){if(arguments.length<1)throw new RangeError("missing argument: identifier is required");const t=Ro(e);Nt(this),W(this,Ut,t)}get id(){if(!Ct(this))throw new TypeError("invalid receiver");return L(this)}getOffsetNanosecondsFor(e){if(!Ct(this))throw new TypeError("invalid receiver");const t=Dt(e),n=o(this,Ut);return yn(n)?an(n):Ft(o(t,P),n)}getOffsetStringFor(e){if(!Ct(this))throw new TypeError("invalid receiver");return io(this,Dt(e))}getPlainDateTimeFor(e,t=Ce()){return mt(this,Dt(e),Ae(t))}getInstantFor(e,t){if(!Ct(this))throw new TypeError("invalid receiver");return tt(this,St(e),Un(z(t)))}getPossibleInstantsFor(e){if(!Ct(this))throw new TypeError("invalid receiver");const t=St(e),n=x("%Temporal.Instant%"),r=o(this,Ut);if(yn(r)){const s=Vt(o(t,O),o(t,$),o(t,I),o(t,Z),o(t,j),o(t,A),o(t,q),o(t,U),o(t,S));if(s===null)throw new RangeError("DateTime outside of supported range");const a=an(r);return[new n(h.subtract(s,h.BigInt(a)))]}return function(a,c,l,d,m,u,f,y,g,w){const p=Vt(c,l,d,m,u,f,y,g,w);if(p===null)throw new RangeError("DateTime outside of supported range");let v=h.subtract(p,Wt);h.lessThan(v,jn)&&(v=p);let T=h.add(p,Wt);h.greaterThan(T,An)&&(T=p);const b=Ft(v,a),D=Ft(T,a);return(b===D?[b]:[b,D]).map(_=>{const C=h.subtract(p,h.BigInt(_)),M=Si(C,a);if(c===M.year&&l===M.month&&d===M.day&&m===M.hour&&u===M.minute&&f===M.second&&y===M.millisecond&&g===M.microsecond&&w===M.nanosecond)return C}).filter(_=>_!==void 0)}(r,o(t,O),o(t,$),o(t,I),o(t,Z),o(t,j),o(t,A),o(t,q),o(t,U),o(t,S)).map(s=>new n(s))}getNextTransition(e){if(!Ct(this))throw new TypeError("invalid receiver");const t=Dt(e),n=o(this,Ut);if(yn(n)||n==="UTC")return null;let r=o(t,P);const s=x("%Temporal.Instant%");return r=function(c,l){const d=h.add(c,Ci),m=ii(zi(),d);let u=ii(_i,c);const f=Ft(u,l);let y=u,g=f;for(;f===g&&h.lessThan(h.BigInt(u),m);)y=h.add(u,Mi),g=Ft(y,l),f===g&&(u=y);return f===g?null:es(w=>Ft(w,l),u,y,f,g)}(r,n),r===null?null:new s(r)}getPreviousTransition(e){if(!Ct(this))throw new TypeError("invalid receiver");const t=Dt(e),n=o(this,Ut);if(yn(n)||n==="UTC")return null;let r=o(t,P);const s=x("%Temporal.Instant%");return r=Gi(r,n),r===null?null:new s(r)}toString(){if(!Ct(this))throw new TypeError("invalid receiver");return L(o(this,Ut))}toJSON(){if(!Ct(this))throw new TypeError("invalid receiver");return L(this)}static from(e){return nt(e)}}Yt(Lo,"Temporal.TimeZone");const ua=Object.create,lr=["week","day","hour","minute","second","millisecond","microsecond","nanosecond"];class Zo{constructor(e,t,n=Ce(),r=1){const s=he(e),a=he(t),c=Ae(n),l=he(r);if(arguments.length<2)throw new RangeError("missing argument: isoYear and isoMonth are required");Li(this,s,a,c,l)}get year(){if(!ne(this))throw new TypeError("invalid receiver");return kr(o(this,E),this)}get month(){if(!ne(this))throw new TypeError("invalid receiver");return Ir(o(this,E),this)}get monthCode(){if(!ne(this))throw new TypeError("invalid receiver");return nr(o(this,E),this)}get calendar(){if(!ne(this))throw new TypeError("invalid receiver");return o(this,E)}get era(){if(!ne(this))throw new TypeError("invalid receiver");return Nr(o(this,E),this)}get eraYear(){if(!ne(this))throw new TypeError("invalid receiver");return Pr(o(this,E),this)}get daysInMonth(){if(!ne(this))throw new TypeError("invalid receiver");return wn(o(this,E),this)}get daysInYear(){if(!ne(this))throw new TypeError("invalid receiver");return Fr(o(this,E),this)}get monthsInYear(){if(!ne(this))throw new TypeError("invalid receiver");return xr(o(this,E),this)}get inLeapYear(){if(!ne(this))throw new TypeError("invalid receiver");return Lr(o(this,E),this)}with(e,t){if(!ne(this))throw new TypeError("invalid receiver");if(!ue(e))throw new TypeError("invalid argument");$n(e);const n=o(this,E),r=Ee(n,["month","monthCode","year"]),s=Bt(e,r);if(!s)throw new TypeError("invalid year-month-like");let a=it(this,r);return a=sn(n,a,s),a=it(a,r),Ht(n,a,z(t))}add(e,t){if(!ne(this))throw new TypeError("invalid receiver");const n=vt(e);let{years:r,months:s,weeks:a,days:c,hours:l,minutes:d,seconds:m,milliseconds:u,microseconds:f,nanoseconds:y}=n;({days:c}=je(c,l,d,m,u,f,y,"day"));const g=z(t),w=o(this,E),p=Ee(w,["monthCode","year"]),v=bt(w,de(Q({},it(this,p)),{day:pt(r,s,a,c,0,0,0,0,0,0)<0?En(wn(w,this)):1})),T=Q({},g);return Ht(w,it(Ke(w,v,de(Q({},n),{days:c}),g),p),T)}subtract(e,t){if(!ne(this))throw new TypeError("invalid receiver");let n=vt(e);n={years:-n.years,months:-n.months,weeks:-n.weeks,days:-n.days,hours:-n.hours,minutes:-n.minutes,seconds:-n.seconds,milliseconds:-n.milliseconds,microseconds:-n.microseconds,nanoseconds:-n.nanoseconds};let{years:r,months:s,weeks:a,days:c,hours:l,minutes:d,seconds:m,milliseconds:u,microseconds:f,nanoseconds:y}=n;({days:c}=je(c,l,d,m,u,f,y,"day"));const g=z(t),w=o(this,E),p=Ee(w,["monthCode","year"]),v=bt(w,de(Q({},it(this,p)),{day:pt(r,s,a,c,0,0,0,0,0,0)<0?En(wn(w,this)):1})),T=Q({},g);return Ht(w,it(Ke(w,v,de(Q({},n),{days:c}),g),p),T)}until(e,t){if(!ne(this))throw new TypeError("invalid receiver");const n=dn(e),r=o(this,E),s=o(n,E),a=L(r),c=L(s);if(a!==c)throw new RangeError(`cannot compute difference between months of ${a} and ${c} calendars`);const l=z(t),d=Je(l,"month",lr),m=ut(l,"auto",lr,"year");yt(m,d);const u=Oe(l,"trunc"),f=ft(l,void 0,!1),y=Ee(r,["monthCode","year"]),g=it(n,y),w=it(this,y),p=bt(r,de(Q({},g),{day:1})),v=bt(r,de(Q({},w),{day:1})),T=Ot(r,v,p,de(Q({},l),{largestUnit:m}));if(d==="month"&&f===1)return T;let{years:b,months:D}=T;return{years:b,months:D}=gt(b,D,0,0,0,0,0,0,0,0,f,d,u,v),new(x("%Temporal.Duration%"))(b,D,0,0,0,0,0,0,0,0)}since(e,t){if(!ne(this))throw new TypeError("invalid receiver");const n=dn(e),r=o(this,E),s=o(n,E),a=L(r),c=L(s);if(a!==c)throw new RangeError(`cannot compute difference between months of ${a} and ${c} calendars`);const l=z(t),d=Je(l,"month",lr),m=ut(l,"auto",lr,"year");yt(m,d);const u=Oe(l,"trunc"),f=ft(l,void 0,!1),y=Ee(r,["monthCode","year"]),g=it(n,y),w=it(this,y),p=bt(r,de(Q({},g),{day:1})),v=bt(r,de(Q({},w),{day:1})),T=de(Q({},l),{largestUnit:m});let{years:b,months:D}=Ot(r,v,p,T);const _=x("%Temporal.Duration%");return d==="month"&&f===1||({years:b,months:D}=gt(b,D,0,0,0,0,0,0,0,0,f,d,Kn(u),v)),new _(-b,-D,0,0,0,0,0,0,0,0)}equals(e){if(!ne(this))throw new TypeError("invalid receiver");const t=dn(e);for(const n of[O,$,I])if(o(this,n)!==o(t,n))return!1;return rr(o(this,E),o(t,E))}toString(e){if(!ne(this))throw new TypeError("invalid receiver");return ri(this,Jn(z(e)))}toJSON(){if(!ne(this))throw new TypeError("invalid receiver");return ri(this)}toLocaleString(e,t){if(!ne(this))throw new TypeError("invalid receiver");return new Xt(e,t).format(this)}valueOf(){throw new TypeError("use compare() or equals() to compare Temporal.PlainYearMonth")}toPlainDate(e){if(!ne(this))throw new TypeError("invalid receiver");if(!ue(e))throw new TypeError("argument should be an object");const t=o(this,E),n=Ee(t,["monthCode","year"]),r=it(this,n),s=Ee(t,["day"]),a=[["day"]];s.forEach(u=>{a.some(([f])=>f===u)||a.push([u,void 0])});let c=sn(t,r,Ze(e,a));const l=[...new Set([...n,...s])],d=[];l.forEach(u=>{d.some(([f])=>f===u)||d.push([u,void 0])}),c=Ze(c,d);const m=ua(null);return m.overflow="reject",bt(t,c,m)}getISOFields(){if(!ne(this))throw new TypeError("invalid receiver");return{calendar:o(this,E),isoDay:o(this,I),isoMonth:o(this,$),isoYear:o(this,O)}}static from(e,t){const n=z(t);return ne(e)?(Le(n),Gn(o(e,O),o(e,$),o(e,E),o(e,I))):dn(e,n)}static compare(e,t){const n=dn(e),r=dn(t);return Lt(o(n,O),o(n,$),o(n,I),o(r,O),o(r,$),o(r,I))}}Yt(Zo,"Temporal.PlainYearMonth");const ma=Array.prototype.push;class jo{constructor(e,t,n=Ce()){if(arguments.length<1)throw new TypeError("missing argument: epochNanoseconds is required");Zi(this,pn(e),nt(t),Ae(n))}get calendar(){if(!Y(this))throw new TypeError("invalid receiver");return o(this,E)}get timeZone(){if(!Y(this))throw new TypeError("invalid receiver");return o(this,ee)}get year(){if(!Y(this))throw new TypeError("invalid receiver");return kr(o(this,E),me(this))}get month(){if(!Y(this))throw new TypeError("invalid receiver");return Ir(o(this,E),me(this))}get monthCode(){if(!Y(this))throw new TypeError("invalid receiver");return nr(o(this,E),me(this))}get day(){if(!Y(this))throw new TypeError("invalid receiver");return Yr(o(this,E),me(this))}get hour(){if(!Y(this))throw new TypeError("invalid receiver");return o(me(this),Z)}get minute(){if(!Y(this))throw new TypeError("invalid receiver");return o(me(this),j)}get second(){if(!Y(this))throw new TypeError("invalid receiver");return o(me(this),A)}get millisecond(){if(!Y(this))throw new TypeError("invalid receiver");return o(me(this),q)}get microsecond(){if(!Y(this))throw new TypeError("invalid receiver");return o(me(this),U)}get nanosecond(){if(!Y(this))throw new TypeError("invalid receiver");return o(me(this),S)}get era(){if(!Y(this))throw new TypeError("invalid receiver");return Nr(o(this,E),me(this))}get eraYear(){if(!Y(this))throw new TypeError("invalid receiver");return Pr(o(this,E),me(this))}get epochSeconds(){if(!Y(this))throw new TypeError("invalid receiver");const e=o(this,P);return h.toNumber(h.divide(e,At))}get epochMilliseconds(){if(!Y(this))throw new TypeError("invalid receiver");const e=o(this,P);return h.toNumber(h.divide(e,lt))}get epochMicroseconds(){if(!Y(this))throw new TypeError("invalid receiver");const e=o(this,P);return Rr(h.divide(e,oe))}get epochNanoseconds(){if(!Y(this))throw new TypeError("invalid receiver");return Rr(o(this,P))}get dayOfWeek(){if(!Y(this))throw new TypeError("invalid receiver");return bo(o(this,E),me(this))}get dayOfYear(){if(!Y(this))throw new TypeError("invalid receiver");return Do(o(this,E),me(this))}get weekOfYear(){if(!Y(this))throw new TypeError("invalid receiver");return _o(o(this,E),me(this))}get hoursInDay(){if(!Y(this))throw new TypeError("invalid receiver");const e=me(this),t=x("%Temporal.PlainDateTime%"),n=o(e,O),r=o(e,$),s=o(e,I),a=new t(n,r,s,0,0,0,0,0,0),c=nn(n,r,s,0,0,0,1,"reject"),l=new t(c.year,c.month,c.day,0,0,0,0,0,0),d=o(this,ee),m=o(tt(d,a,"compatible"),P),u=o(tt(d,l,"compatible"),P);return h.toNumber(h.subtract(u,m))/36e11}get daysInWeek(){if(!Y(this))throw new TypeError("invalid receiver");return Co(o(this,E),me(this))}get daysInMonth(){if(!Y(this))throw new TypeError("invalid receiver");return wn(o(this,E),me(this))}get daysInYear(){if(!Y(this))throw new TypeError("invalid receiver");return Fr(o(this,E),me(this))}get monthsInYear(){if(!Y(this))throw new TypeError("invalid receiver");return xr(o(this,E),me(this))}get inLeapYear(){if(!Y(this))throw new TypeError("invalid receiver");return Lr(o(this,E),me(this))}get offset(){if(!Y(this))throw new TypeError("invalid receiver");return io(o(this,ee),o(this,qe))}get offsetNanoseconds(){if(!Y(this))throw new TypeError("invalid receiver");return _t(o(this,ee),o(this,qe))}with(e,t){if(!Y(this))throw new TypeError("invalid receiver");if(!ue(e))throw new TypeError("invalid zoned-date-time-like");$n(e);const n=z(t),r=Un(n),s=no(n,"prefer"),a=o(this,ee),c=o(this,E),l=Ee(c,["day","hour","microsecond","millisecond","minute","month","monthCode","nanosecond","second","year"]);ma.call(l,"offset");const d=Bt(e,l);if(!d)throw new TypeError("invalid zoned-date-time-like");const m=[["day",void 0],["hour",0],["microsecond",0],["millisecond",0],["minute",0],["month",void 0],["monthCode",void 0],["nanosecond",0],["second",0],["year",void 0],["offset"],["timeZone"]];l.forEach(_=>{m.some(([C])=>C===_)||m.push([_,void 0])});let u=Ze(this,m);u=sn(c,u,d),u=Ze(u,m);const{year:f,month:y,day:g,hour:w,minute:p,second:v,millisecond:T,microsecond:b,nanosecond:D}=tr(c,u,n);return Fe(Tr(f,y,g,w,p,v,T,b,D,"option",an(u.offset),a,r,s,!1),o(this,ee),c)}withPlainDate(e){if(!Y(this))throw new TypeError("invalid receiver");const t=ce(e),n=o(t,O),r=o(t,$),s=o(t,I);let a=o(t,E);const c=me(this),l=o(c,Z),d=o(c,j),m=o(c,A),u=o(c,q),f=o(c,U),y=o(c,S);a=ji(o(this,E),a);const g=o(this,ee);return Fe(o(tt(g,new(x("%Temporal.PlainDateTime%"))(n,r,s,l,d,m,u,f,y,a),"compatible"),P),g,a)}withPlainTime(e){if(!Y(this))throw new TypeError("invalid receiver");const t=x("%Temporal.PlainTime%"),n=e==null?new t:Mt(e),r=me(this),s=o(r,O),a=o(r,$),c=o(r,I),l=o(this,E),d=o(n,Z),m=o(n,j),u=o(n,A),f=o(n,q),y=o(n,U),g=o(n,S),w=o(this,ee);return Fe(o(tt(w,new(x("%Temporal.PlainDateTime%"))(s,a,c,d,m,u,f,y,g,l),"compatible"),P),w,l)}withTimeZone(e){if(!Y(this))throw new TypeError("invalid receiver");const t=nt(e);return Fe(o(this,P),t,o(this,E))}withCalendar(e){if(!Y(this))throw new TypeError("invalid receiver");const t=Ae(e);return Fe(o(this,P),o(this,ee),t)}add(e,t){if(!Y(this))throw new TypeError("invalid receiver");const n=vt(e),{years:r,months:s,weeks:a,days:c,hours:l,minutes:d,seconds:m,milliseconds:u,microseconds:f,nanoseconds:y}=n,g=z(t),w=o(this,ee),p=o(this,E);return Fe(dt(o(this,qe),w,p,r,s,a,c,l,d,m,u,f,y,g),w,p)}subtract(e,t){if(!Y(this))throw new TypeError("invalid receiver");const n=vt(e),{years:r,months:s,weeks:a,days:c,hours:l,minutes:d,seconds:m,milliseconds:u,microseconds:f,nanoseconds:y}=n,g=z(t),w=o(this,ee),p=o(this,E);return Fe(dt(o(this,qe),w,p,-r,-s,-a,-c,-l,-d,-m,-u,-f,-y,g),w,p)}until(e,t){if(!Y(this))throw new TypeError("invalid receiver");const n=un(e),r=o(this,E),s=o(n,E),a=L(r),c=L(s);if(a!==c)throw new RangeError(`cannot compute difference between dates of ${a} and ${c} calendars`);const l=z(t),d=Je(l,"nanosecond"),m=ut(l,"auto",[],Tt("hour",d));yt(m,d);const u=Oe(l,"trunc"),f=Sn(l,d),y=o(this,P),g=o(n,P);let w,p,v,T,b,D,_,C,M,k;if(m!=="year"&&m!=="month"&&m!=="week"&&m!=="day")w=0,p=0,v=0,T=0,{seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=Wn(y,g,f,d,u),{hours:b,minutes:D,seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=je(0,0,0,_,C,M,k,m);else{const N=o(this,ee);if(!Hr(N,o(n,ee)))throw new RangeError("When calculating difference between time zones, largestUnit must be 'hours' or smaller because day lengths can vary between time zones due to DST or time zone offset changes.");const J=de(Q({},l),{largestUnit:m});({years:w,months:p,weeks:v,days:T,hours:b,minutes:D,seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=ao(y,g,N,r,m,J)),{years:w,months:p,weeks:v,days:T,hours:b,minutes:D,seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=gt(w,p,v,T,b,D,_,C,M,k,f,d,u,this),{years:w,months:p,weeks:v,days:T,hours:b,minutes:D,seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=uo(w,p,v,T,b,D,_,C,M,k,f,d,u,this)}return new(x("%Temporal.Duration%"))(w,p,v,T,b,D,_,C,M,k)}since(e,t){if(!Y(this))throw new TypeError("invalid receiver");const n=un(e),r=o(this,E),s=o(n,E),a=L(r),c=L(s);if(a!==c)throw new RangeError(`cannot compute difference between dates of ${a} and ${c} calendars`);const l=z(t),d=Je(l,"nanosecond"),m=ut(l,"auto",[],Tt("hour",d));yt(m,d);let u=Oe(l,"trunc");u=Kn(u);const f=Sn(l,d),y=o(this,P),g=o(n,P);let w,p,v,T,b,D,_,C,M,k;if(m!=="year"&&m!=="month"&&m!=="week"&&m!=="day")w=0,p=0,v=0,T=0,{seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=Wn(y,g,f,d,u),{hours:b,minutes:D,seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=je(0,0,0,_,C,M,k,m);else{const N=o(this,ee);if(!Hr(N,o(n,ee)))throw new RangeError("When calculating difference between time zones, largestUnit must be 'hours' or smaller because day lengths can vary between time zones due to DST or time zone offset changes.");const J=de(Q({},l),{largestUnit:m});({years:w,months:p,weeks:v,days:T,hours:b,minutes:D,seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=ao(y,g,N,r,m,J)),{years:w,months:p,weeks:v,days:T,hours:b,minutes:D,seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=gt(w,p,v,T,b,D,_,C,M,k,f,d,u,this),{years:w,months:p,weeks:v,days:T,hours:b,minutes:D,seconds:_,milliseconds:C,microseconds:M,nanoseconds:k}=uo(w,p,v,T,b,D,_,C,M,k,f,d,u,this)}return new(x("%Temporal.Duration%"))(-w,-p,-v,-T,-b,-D,-_,-C,-M,-k)}round(e){if(!Y(this))throw new TypeError("invalid receiver");if(e===void 0)throw new TypeError("options parameter is required");const t=typeof e=="string"?Cn("smallestUnit",e):z(e),n=Je(t,void 0,["year","month","week"]);if(n===void 0)throw new RangeError("smallestUnit is required");const r=Oe(t,"halfExpand"),s=ft(t,{day:1,hour:24,minute:60,second:60,millisecond:1e3,microsecond:1e3,nanosecond:1e3}[n],!1),a=me(this);let c=o(a,O),l=o(a,$),d=o(a,I),m=o(a,Z),u=o(a,j),f=o(a,A),y=o(a,q),g=o(a,U),w=o(a,S);const p=x("%Temporal.PlainDateTime%"),v=o(this,ee),T=o(this,E),b=tt(v,new p(o(a,O),o(a,$),o(a,I),0,0,0,0,0,0),"compatible"),D=dt(b,v,T,0,0,0,1,0,0,0,0,0,0),_=h.subtract(D,h.BigInt(o(b,P)));if(h.equal(_,_e))throw new RangeError("cannot round a ZonedDateTime in a calendar with zero-length days");return{year:c,month:l,day:d,hour:m,minute:u,second:f,millisecond:y,microsecond:g,nanosecond:w}=Io(c,l,d,m,u,f,y,g,w,s,n,r,h.toNumber(_)),Fe(Tr(c,l,d,m,u,f,y,g,w,"option",_t(v,o(this,qe)),v,"compatible","prefer",!1),v,o(this,E))}equals(e){if(!Y(this))throw new TypeError("invalid receiver");const t=un(e),n=o(this,P),r=o(t,P);return!!h.equal(h.BigInt(n),h.BigInt(r))&&!!Hr(o(this,ee),o(t,ee))&&rr(o(this,E),o(t,E))}toString(e){if(!Y(this))throw new TypeError("invalid receiver");const t=z(e),{precision:n,unit:r,increment:s}=er(t),a=Oe(t,"trunc");return oi(this,n,Jn(t),function(l){return kt(l,"timeZoneName",["auto","never"],"auto")}(t),function(l){return kt(l,"offset",["auto","never"],"auto")}(t),{unit:r,increment:s,roundingMode:a})}toLocaleString(e,t){if(!Y(this))throw new TypeError("invalid receiver");return new Xt(e,t).format(this)}toJSON(){if(!Y(this))throw new TypeError("invalid receiver");return oi(this,"auto")}valueOf(){throw new TypeError("use compare() or equals() to compare Temporal.ZonedDateTime")}startOfDay(){if(!Y(this))throw new TypeError("invalid receiver");const e=me(this),t=x("%Temporal.PlainDateTime%"),n=o(this,E),r=new t(o(e,O),o(e,$),o(e,I),0,0,0,0,0,0,n),s=o(this,ee);return Fe(o(tt(s,r,"compatible"),P),s,n)}toInstant(){if(!Y(this))throw new TypeError("invalid receiver");return new(x("%Temporal.Instant%"))(o(this,P))}toPlainDate(){if(!Y(this))throw new TypeError("invalid receiver");return tn(me(this))}toPlainTime(){if(!Y(this))throw new TypeError("invalid receiver");return Mo(me(this))}toPlainDateTime(){if(!Y(this))throw new TypeError("invalid receiver");return me(this)}toPlainYearMonth(){if(!Y(this))throw new TypeError("invalid receiver");const e=o(this,E);return Ht(e,it(this,Ee(e,["monthCode","year"])))}toPlainMonthDay(){if(!Y(this))throw new TypeError("invalid receiver");const e=o(this,E);return Dn(e,en(this,Ee(e,["day","monthCode"])))}getISOFields(){if(!Y(this))throw new TypeError("invalid receiver");const e=me(this),t=o(this,ee);return{calendar:o(this,E),isoDay:o(e,I),isoHour:o(e,Z),isoMicrosecond:o(e,U),isoMillisecond:o(e,q),isoMinute:o(e,j),isoMonth:o(e,$),isoNanosecond:o(e,S),isoSecond:o(e,A),isoYear:o(e,O),offset:io(t,o(this,qe)),timeZone:t}}static from(e,t){const n=z(t);return Y(e)?(Le(n),Un(n),no(n,"reject"),Fe(o(e,P),o(e,ee),o(e,E))):un(e,n)}static compare(e,t){const n=un(e),r=un(t),s=o(n,P),a=o(r,P);return h.lessThan(h.BigInt(s),h.BigInt(a))?-1:h.greaterThan(h.BigInt(s),h.BigInt(a))?1:0}}function me(i){return mt(o(i,ee),o(i,qe),o(i,E))}Yt(jo,"Temporal.ZonedDateTime");Object.freeze({__proto__:null,Instant:ht,Calendar:yr,PlainDate:ir,PlainDateTime:sr,Duration:Rt,PlainMonthDay:Fo,Now:ls,PlainTime:Zt,TimeZone:Lo,PlainYearMonth:Zo,ZonedDateTime:jo});function ga(){const i=h.multiply(h.BigInt(+this),lt);return new ht(pn(i))}const fa=[ht,yr,ir,sr,Rt,Fo,Zt,Lo,Zo,jo];for(const i of fa){const e=Object.getOwnPropertyDescriptor(i,"prototype");(e.configurable||e.enumerable||e.writable)&&(e.configurable=!1,e.enumerable=!1,e.writable=!1,Object.defineProperty(i,"prototype",e))}export{ga as t};
